<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manifolds &mdash; Pymanopt stable (2.1.1) documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" type="text/css" />
      <link rel="stylesheet" href="_static/katex-math.css" type="text/css" />
    <link rel="canonical" href="pymanopt.org/manifolds.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"></script>
        <script src="_static/katex_autorenderer.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Automatic Differentiation" href="autodiff.html" />
    <link rel="prev" title="API Reference" href="api-reference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Pymanopt
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                stable (2.1.1)
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pymanopt/pymanopt/tree/master/examples">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api-reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Manifolds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.manifold">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id10">Euclidean Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.sphere">Sphere Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">Stiefel Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">Grassmann Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.complex_circle">Complex Circle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.special_orthogonal_group">Special Orthogonal Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.oblique">Oblique Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.positive_definite">Symmetric Positive Definite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.psd">Positive Semidefinite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.fixed_rank">Fixed-Rank Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.positive">Positive Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.hyperbolic">Hyperbolic Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.product">Product Manifold</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="autodiff.html">Automatic Differentiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimizers.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples/notebooks/mixture_of_gaussians.html">Riemannian Optimization for Inference in MoG models</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pymanopt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="api-reference.html">API Reference</a> &raquo;</li>
      <li>Manifolds</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/manifolds.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="manifolds">
<h1>Manifolds<a class="headerlink" href="#manifolds" title="Permalink to this headline"></a></h1>
<p>The rigorous mathematical definition of a manifold is beyond the scope of this
documentation.
However, if you are unfamiliar with the idea, it is fine just to visualize it
as a smooth subset of <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_space">Euclidean space</a>.
Simple examples include the surface of a sphere or a <a class="reference external" href="https://en.wikipedia.org/wiki/Torus">torus</a>, or the <a class="reference external" href="https://en.wikipedia.org/wiki/Möbius_strip">Möbius strip</a>.
For an exact definition and a general background on Riemannian optimization we
refer readers to the monographs <a class="reference internal" href="bibliography.html#ams2008" id="id1"><span>[AMS2008]</span></a> and <a class="reference internal" href="bibliography.html#bou2020" id="id2"><span>[Bou2020]</span></a> (both of which are
freely available online).
If you need to solve an optimization problem with a search space that is
constrained in some smooth way, then performing optimization on manifolds may
well be the natural approach to take.</p>
<p>The manifolds that we currently support are listed below.
We plan to implement more depending on the needs of users, so if there is a
particular manifold you would like to optimize over, please let us know.
If you wish to implement your own manifold for Pymanopt, you will
need to inherit from the abstract <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>
or <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a> base
class.</p>
<div class="section" id="module-pymanopt.manifolds.manifold">
<span id="manifold"></span><h2>Manifold<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Riemannian manifold base class.</p>
<p>Abstract base class setting out a template for manifold classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – String representation of the manifold.</p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – The dimension of the manifold, i.e., the vector space
dimension of the tangent spaces.</p></li>
<li><p><strong>point_layout</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>Sequence</em><em>[</em><em>int</em><em>]</em><em>]</em>) – Abstract description of the representation of points on
the manifold.
For manifolds representing points as simple numpy arrays,
<code class="docutils literal notranslate"><span class="pre">point_layout</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>.
For more complicated manifolds which might represent points as a
tuple or list of <code class="docutils literal notranslate"><span class="pre">n</span></code> arrays, <cite>point_layout</cite> would be <code class="docutils literal notranslate"><span class="pre">n</span></code>.
Finally, in the special case of the
<a class="reference internal" href="#pymanopt.manifolds.product.Product" title="pymanopt.manifolds.product.Product"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.product.Product</span></code></a> manifold
<code class="docutils literal notranslate"><span class="pre">point_layout</span></code> will be a compound sequence of point layouts of
manifolds involved in the product.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not all methods are required by all optimizers.
In particular, first order gradient based optimizers such as
<a class="reference internal" href="optimizers.html#pymanopt.optimizers.steepest_descent.SteepestDescent" title="pymanopt.optimizers.steepest_descent.SteepestDescent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.optimizers.steepest_descent.SteepestDescent</span></code></a> and
<a class="reference internal" href="optimizers.html#pymanopt.optimizers.conjugate_gradient.ConjugateGradient" title="pymanopt.optimizers.conjugate_gradient.ConjugateGradient"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.optimizers.conjugate_gradient.ConjugateGradient</span></code></a> require
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_gradient()</span></code></a> to be implemented but not
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>.
Second-order optimizers such as
<a class="reference internal" href="optimizers.html#pymanopt.optimizers.trust_regions.TrustRegions" title="pymanopt.optimizers.trust_regions.TrustRegions"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.optimizers.trust_regions.TrustRegions</span></code></a> will require
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.point_layout" title="pymanopt.manifolds.manifold.Manifold.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.typical_dist" title="pymanopt.manifolds.manifold.Manifold.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.inner_product">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>numpy.ndarray</em>) – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> (<em>numpy.ndarray</em>) – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> (<em>numpy.ndarray</em>) – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.projection">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.norm">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.random_point">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.random_tangent_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.zero_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.exp" title="pymanopt.manifolds.manifold.Manifold.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id3"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id4"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">RiemannianSubmanifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Base class for Riemannian submanifolds of Euclidean space.</p>
<p>This class provides a generic method to project Euclidean gradients to
their Riemannian counterparts via the
<a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_gradient()</span></code></a> method.
Similarly, if the Weingarten map (also known as shape operator) is provided
via implementing the <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weingarten()</span></code></a> method, the class provides a
generic implementation of the <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>
method required by second-order optimizers to translate Euclidean
Hessian-vector products to their Riemannian counterparts.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class follows definition 3.47 in <a class="reference internal" href="bibliography.html#bou2020" id="id5"><span>[Bou2020]</span></a> of “Riemannian
submanifolds”.
As such, manifolds derived from this class are assumed to be embedded
submanifolds of Euclidean space with the Riemannian metric inherited
from the embedding space obtained by restricting it to the tangent
space at a given point.</p>
<p>For the exact definition of the Weingarten map refer to <a class="reference internal" href="bibliography.html#amt2013" id="id6"><span>[AMT2013]</span></a> and
the notes in section 5.11 of <a class="reference internal" href="bibliography.html#bou2020" id="id7"><span>[Bou2020]</span></a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – </p></li>
<li><p><strong>dimension</strong> (<em>int</em>) – </p></li>
<li><p><strong>point_layout</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>Sequence</em><em>[</em><em>int</em><em>]</em><em>]</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.weingarten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.inner_product">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>numpy.ndarray</em>) – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> (<em>numpy.ndarray</em>) – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> (<em>numpy.ndarray</em>) – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.exp" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.norm">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.point_layout" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.projection">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.random_point">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.random_tangent_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id8"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id9"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.typical_dist" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.zero_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RetrAsExpMixin">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">RetrAsExpMixin</span></span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RetrAsExpMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RetrAsExpMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin which defers calls to the exponential map to the retraction.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RetrAsExpMixin.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RetrAsExpMixin.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RetrAsExpMixin.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id10">
<h2>Euclidean Space<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2>
<span class="target" id="module-pymanopt.manifolds.euclidean"></span><dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Euclidean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Euclidean manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>int</em>) – Shape of points on the manifold.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">==</span> <span class="pre">(n,)</span></code>, this is the manifold of vectors with the
standard Euclidean inner product, i.e., <span class="math">\(\R^n\)</span>.
For <code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">==</span> <span class="pre">(m,</span> <span class="pre">n)</span></code>, it corresponds to the manifold of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrices equipped with the standard trace inner product.
For <code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">==</span> <span class="pre">(n1,</span> <span class="pre">n2,</span> <span class="pre">...,</span> <span class="pre">nk)</span></code>, the class represents the manifold
of tensors of shape <code class="docutils literal notranslate"><span class="pre">n1</span> <span class="pre">x</span> <span class="pre">n2</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">x</span> <span class="pre">nk</span></code> with the inner product
corresponding to the usual tensor dot product.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.euclidean.Euclidean.exp" title="pymanopt.manifolds.euclidean.Euclidean.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.euclidean.Euclidean.point_layout" title="pymanopt.manifolds.euclidean.Euclidean.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id11"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id12"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.euclidean.Euclidean.typical_dist" title="pymanopt.manifolds.euclidean.Euclidean.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>(Product) manifold of symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Number of rows and columns of matrices.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Number of elements in the product manifold.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> symmetric matrices as a Riemannian submanifold of
Euclidean space.
If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> then this is the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> symmetric <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span>
<span class="pre">n</span></code> matrices represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.euclidean.Symmetric.exp" title="pymanopt.manifolds.euclidean.Symmetric.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.euclidean.Symmetric.point_layout" title="pymanopt.manifolds.euclidean.Symmetric.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id13"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id14"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.euclidean.Symmetric.typical_dist" title="pymanopt.manifolds.euclidean.Symmetric.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">SkewSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>(Product) manifold of skew-symmetric matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of rows and columns of matrices.</p></li>
<li><p><strong>k</strong> – Number of elements in the product manifold.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> skew-symmetric matrices as a Riemannian
submanifold of Euclidean space.
If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> then this is the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> skew-symmetric
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.euclidean.SkewSymmetric.exp" title="pymanopt.manifolds.euclidean.SkewSymmetric.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.euclidean.SkewSymmetric.point_layout" title="pymanopt.manifolds.euclidean.SkewSymmetric.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id15"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id16"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.euclidean.SkewSymmetric.typical_dist" title="pymanopt.manifolds.euclidean.SkewSymmetric.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.sphere">
<span id="sphere-manifold"></span><h2>Sphere Manifold<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">Sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereBase</span></code></p>
<p>The sphere manifold.</p>
<p>Manifold of shape <span class="math">\(n_1 \times \ldots \times n_k\)</span> tensors with unit
Euclidean norm.
The norm is understood as the <span class="math">\(\ell_2\)</span>-norm of <span class="math">\(\E =
\R^{\sum_{i=1}^k n_i}\)</span> after identifying <span class="math">\(\R^{n_1 \times \ldots
\times n_k}\)</span> with <span class="math">\(\E\)</span>.
The metric is the one inherited from the usual Euclidean inner product that
induces <span class="math">\(\norm{\cdot}_2\)</span> on <span class="math">\(\E\)</span> such that the manifold forms a
Riemannian submanifold of Euclidean space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shape</strong> (<em>int</em>) – The shape of tensors.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Weingarten map is taken from <a class="reference internal" href="bibliography.html#amt2013" id="id17"><span>[AMT2013]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.sphere.Sphere.exp" title="pymanopt.manifolds.sphere.Sphere.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.sphere.Sphere.point_layout" title="pymanopt.manifolds.sphere.Sphere.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id18"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id19"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.sphere.Sphere.typical_dist" title="pymanopt.manifolds.sphere.Sphere.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace intersection manifold.</p>
<p>Manifold of <span class="math">\(n\)</span>-dimensional vectors with unit <span class="math">\(\ell_2\)</span>-norm
intersecting an <span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span>.
The subspace is represented by a matrix of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">r</span></code> whose columns
span the subspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> – Matrix whose columns span the intersecting subspace.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Weingarten map is taken from <a class="reference internal" href="bibliography.html#amt2013" id="id20"><span>[AMT2013]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.exp" title="pymanopt.manifolds.sphere.SphereSubspaceIntersection.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.point_layout" title="pymanopt.manifolds.sphere.SphereSubspaceIntersection.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id21"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id22"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.typical_dist" title="pymanopt.manifolds.sphere.SphereSubspaceIntersection.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceComplementIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceComplementIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace complement intersection manifold.</p>
<p>Manifold of <span class="math">\(n\)</span>-dimensional vectors with unit <span class="math">\(\ell_2\)</span>-norm
that are orthogonal to an <span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span>.
The subspace is represented by a matrix of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">r</span></code> whose columns
span the subspace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> – Matrix whose columns span the subspace.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Weingarten map is taken from <a class="reference internal" href="bibliography.html#amt2013" id="id23"><span>[AMT2013]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.exp" title="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.point_layout" title="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id24"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id25"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.typical_dist" title="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.stiefel">
<span id="stiefel-manifold"></span><h2>Stiefel Manifold<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.stiefel.</span></span><span class="sig-name descname"><span class="pre">Stiefel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qr'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>The (product) Stiefel manifold.</p>
<p>The Stiefel manifold <span class="math">\(\St(n, p)\)</span> is the manifold of orthonormal <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrices.
A point <span class="math">\(\vmX \in \St(n, p)\)</span> therefore satisfies the condition
<span class="math">\(\transp{\vmX}\vmX = \Id_p\)</span>.
Points on the manifold are represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">p)</span></code> if
<code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">1</span></code>.
For <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the class represents the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> Stiefel
manifolds, in which case points on the manifold are represented as arrays
of shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">p)</span></code>.</p>
<p>The metric is the usual Euclidean metric on <span class="math">\(\R^{n \times p}\)</span> which
turns <span class="math">\(\St(n, p)^k\)</span> into a Riemannian submanifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of rows.</p></li>
<li><p><strong>p</strong> (<em>int</em>) – The number of columns.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product.</p></li>
<li><p><strong>retraction</strong> (<em>str</em>) – The type of retraction to use.
Possible choices are <code class="docutils literal notranslate"><span class="pre">qr</span></code> and <code class="docutils literal notranslate"><span class="pre">polar</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The formula for the exponential map can be found in <a class="reference internal" href="bibliography.html#zh2021" id="id26"><span>[ZH2021]</span></a>.</p>
<p>The Weingarten map is taken from <a class="reference internal" href="bibliography.html#amt2013" id="id27"><span>[AMT2013]</span></a>.</p>
<p>The default retraction used here is a first-order one based on
the QR decomposition.
To switch to a second-order polar retraction, use <code class="docutils literal notranslate"><span class="pre">Stiefel(n,</span> <span class="pre">p,</span> <span class="pre">k=k,</span>
<span class="pre">retraction=&quot;polar&quot;)</span></code>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.stiefel.Stiefel.typical_dist" title="pymanopt.manifolds.stiefel.Stiefel.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.weingarten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id28"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id29"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="pymanopt.manifolds.stiefel.Stiefel.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.stiefel.Stiefel.point_layout" title="pymanopt.manifolds.stiefel.Stiefel.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.grassmann">
<span id="grassmann-manifold"></span><h2>Grassmann Manifold<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">Grassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.grassmann._GrassmannBase</span></code></p>
<p>The Grassmann manifold.</p>
<p>This is the manifold of subspaces of dimension <code class="docutils literal notranslate"><span class="pre">p</span></code> of a real vector space
of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>.
The optional argument <code class="docutils literal notranslate"><span class="pre">k</span></code> allows to optimize over the product of <code class="docutils literal notranslate"><span class="pre">k</span></code>
Grassmann manifolds.
Elements are represented as <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">p</span></code> matrices if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">1</span></code>, and as <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span>
<span class="pre">n</span> <span class="pre">x</span> <span class="pre">p</span></code> arrays if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Dimension of the ambient space.</p></li>
<li><p><strong>p</strong> (<em>int</em>) – Dimension of the subspaces.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The geometry assumed here is the one obtained by treating the
Grassmannian as a Riemannian quotient manifold of the Stiefel manifold
(see also <a class="reference internal" href="#pymanopt.manifolds.stiefel.Stiefel" title="pymanopt.manifolds.stiefel.Stiefel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.stiefel.Stiefel</span></code></a>)
with the orthogonal group <span class="math">\(\O(p) = \set{\vmQ \in \R^{p \times p}
: \transp{\vmQ}\vmQ = \vmQ\transp{\vmQ} = \Id_p}\)</span>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="pymanopt.manifolds.grassmann.Grassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann.point_layout" title="pymanopt.manifolds.grassmann.Grassmann.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id30"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id31"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann.typical_dist" title="pymanopt.manifolds.grassmann.Grassmann.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">ComplexGrassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.grassmann._GrassmannBase</span></code></p>
<p>The complex Grassmann manifold.</p>
<p>This is the manifold of subspaces of dimension <code class="docutils literal notranslate"><span class="pre">p</span></code> of complex
vector space of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>.
The optional argument <code class="docutils literal notranslate"><span class="pre">k</span></code> allows to optimize over the product of <code class="docutils literal notranslate"><span class="pre">k</span></code>
complex Grassmannians.
Elements are represented as <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">p</span></code> matrices if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">1</span></code>, and as <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span>
<span class="pre">n</span> <span class="pre">x</span> <span class="pre">p</span></code> arrays if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Dimension of the ambient space.</p></li>
<li><p><strong>p</strong> (<em>int</em>) – Dimension of the subspaces.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Similar to <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann" title="pymanopt.manifolds.grassmann.Grassmann"><code class="xref py py-class docutils literal notranslate"><span class="pre">Grassmann</span></code></a>, the complex Grassmannian is treated
as a Riemannian quotient manifold of the complex Stiefel manifold
with the unitary group <span class="math">\(\U(p) = \set{\vmU \in \R^{p \times p}
: \transp{\vmU}\vmU = \vmU\transp{\vmU} = \Id_p}\)</span>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.exp" title="pymanopt.manifolds.grassmann.ComplexGrassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.point_layout" title="pymanopt.manifolds.grassmann.ComplexGrassmann.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id32"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id33"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.typical_dist" title="pymanopt.manifolds.grassmann.ComplexGrassmann.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.complex_circle">
<span id="complex-circle"></span><h2>Complex Circle<a class="headerlink" href="#module-pymanopt.manifolds.complex_circle" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.complex_circle.</span></span><span class="sig-name descname"><span class="pre">ComplexCircle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of unit-modulus complex numbers.</p>
<p>Manifold of complex vectors <span class="math">\(\vmz\)</span> in <span class="math">\(\C^n\)</span> such that each
component <span class="math">\(z_i\)</span> has unit modulus <span class="math">\(\abs{z_i} = 1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> – The dimension of the underlying complex space.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The manifold structure is the Riemannian submanifold
structure from the embedding space <span class="math">\(\R^2 \times \ldots \times
\R^2\)</span>, i.e., the complex circle identified with the unit circle in the
real plane.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist" title="pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="pymanopt.manifolds.complex_circle.ComplexCircle.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id34"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id35"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.complex_circle.ComplexCircle.point_layout" title="pymanopt.manifolds.complex_circle.ComplexCircle.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.special_orthogonal_group">
<span id="special-orthogonal-group"></span><h2>Special Orthogonal Group<a class="headerlink" href="#module-pymanopt.manifolds.special_orthogonal_group" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.special_orthogonal_group.</span></span><span class="sig-name descname"><span class="pre">SpecialOrthogonalGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qr'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>The (product) manifold of rotation matrices.</p>
<p>The special orthgonal group <span class="math">\(\SO(n)\)</span>.
Points on the manifold are matrices <span class="math">\(\vmQ \in \R^{n
\times n}\)</span> such that each matrix is orthogonal with determinant 1, i.e.,
<span class="math">\(\transp{\vmQ}\vmQ = \vmQ\transp{\vmQ} = \Id_n\)</span> and <span class="math">\(\det(\vmQ)
= 1\)</span>.
For <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the class can be used to optimize over the product manifold
of rotation matrices <span class="math">\(\SO(n)^k\)</span>.
In that case points on the manifold are represented as arrays of shape
<code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>.</p>
<p>The metric is the usual Euclidean one inherited from the embedding space
<span class="math">\((\R^{n \times n})^k\)</span>.
As such <span class="math">\(\SO(n)^k\)</span> forms a Riemannian submanifold.</p>
<p>The tangent space <span class="math">\(\tangent{\vmQ}\SO(n)\)</span> at a point <span class="math">\(\vmQ\)</span> is
given by <span class="math">\(\tangent{\vmQ}\SO(n) = \set{\vmQ \vmOmega \in \R^{n \times
n} \mid \vmOmega = -\transp{\vmOmega}} = \vmQ \Skew(n)\)</span>, where
<span class="math">\(\Skew(n)\)</span> denotes the set of skew-symmetric matrices.
This corresponds to the Lie algebra of <span class="math">\(\SO(n)\)</span>, a fact which is used
here to conveniently represent tangent vectors numerically by their
skew-symmetric factor.
The method <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">embedding()</span></code></a> can be used to transform a tangent vector from
its Lie algebra representation to the embedding space representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The dimension of the space that elements of the group act on.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product of groups.</p></li>
<li><p><strong>retraction</strong> (<em>str</em>) – The type of retraction to use.
Possible choices are <code class="docutils literal notranslate"><span class="pre">qr</span></code> and <code class="docutils literal notranslate"><span class="pre">polar</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default SVD-based retraction is only a first-order approximation of
the exponential map.
Use of a second-order retraction can be enabled by instantiating the
class with <code class="docutils literal notranslate"><span class="pre">SpecialOrthogonalGroup(n,</span> <span class="pre">k=k,</span> <span class="pre">retraction=&quot;polar&quot;)</span></code>.</p>
<p>The procedure to generate random rotation matrices sampled uniformly
from the Haar measure is detailed in <a class="reference internal" href="bibliography.html#mez2006" id="id36"><span>[Mez2006]</span></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id37"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id38"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.point_layout" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.oblique">
<span id="oblique-manifold"></span><h2>Oblique Manifold<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.oblique.</span></span><span class="sig-name descname"><span class="pre">Oblique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of matrices with unit-norm columns.</p>
<p>The oblique manifold deals with matrices of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> such that each
column has unit Euclidean norm, i.e., is a point on the unit sphere in
<span class="math">\(\R^m\)</span>.
The metric is such that the oblique manifold is a Riemannian submanifold of
the space of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices with the usual trace inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows of each matrix.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns of each matrix.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique.typical_dist" title="pymanopt.manifolds.oblique.Oblique.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique.exp" title="pymanopt.manifolds.oblique.Oblique.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id39"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id40"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique.point_layout" title="pymanopt.manifolds.oblique.Oblique.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.positive_definite">
<span id="symmetric-positive-definite-matrices"></span><h2>Symmetric Positive Definite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.positive_definite" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.positive_definite.</span></span><span class="sig-name descname"><span class="pre">SymmetricPositiveDefinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of symmetric positive definite matrices.</p>
<p>Points on the manifold and tangent vectors are represented as arrays of
shape <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The size of matrices in the manifold, i.e., the number of rows and
columns of each element.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product geometry.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The geometry is based on the discussion in chapter 6 of <a class="reference internal" href="bibliography.html#bha2007" id="id41"><span>[Bha2007]</span></a>.
Also see <a class="reference internal" href="bibliography.html#sh2015" id="id42"><span>[SH2015]</span></a> for more details.</p>
<p>The second-order retraction is taken from <a class="reference internal" href="bibliography.html#jvv2012" id="id43"><span>[JVV2012]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist" title="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id44"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id45"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp" title="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.point_layout" title="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.psd">
<span id="positive-semidefinite-matrices"></span><h2>Positive Semidefinite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank positive semidefinite (PSD) matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Number of rows and columns of a point in the ambient space.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – Rank of matrices in the ambient space.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A point <span class="math">\(\vmX\)</span> on the manifold is parameterized as <span class="math">\(\vmX =
\vmY\transp{\vmY}\)</span> where <span class="math">\(\vmY\)</span> is a real matrix of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span>
<span class="pre">k</span></code> and rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.
As such, <span class="math">\(\vmX\)</span> is symmetric, positive semidefinite with rank
<code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p>Tangent vectors <span class="math">\(\dot{\vmY}\)</span> are represented as matrices of the
same size as points on the manifold so that tangent vectors in the
ambient space <span class="math">\(\R^{n \times n}\)</span> correspond to <span class="math">\(\dot{\vmX} =
\vmY\transp{\dot{\vmY}} + \dot{\vmY}\transp{\vmY}\)</span>.
The metric is the canonical Euclidean metric on <span class="math">\(\R^{n \times
k}\)</span>.</p>
<p>Since for any orthogonal matrix <span class="math">\(\vmQ\)</span> of size <span class="math">\(k \times k\)</span>
it holds that <span class="math">\(\vmY\vmQ\transp{(\vmY\vmQ)} = \vmY\transp{\vmY}\)</span>,
we identify all matrices of the form <span class="math">\(\vmY\vmQ\)</span> with an
equivalence class.
This set of equivalence classes then forms a Riemannian quotient
manifold which is implemented here.</p>
<p>Notice that this manifold is not complete: if optimization leads points
to be rank-deficient, the geometry will break down.
Hence, this geometry should only be used if it is expected that the
points of interest will have rank exactly <code class="docutils literal notranslate"><span class="pre">k</span></code>.
Reduce <code class="docutils literal notranslate"><span class="pre">k</span></code> if that is not the case.</p>
<p>The quotient geometry implemented here is the simplest case presented
in <a class="reference internal" href="bibliography.html#jba-2010" id="id46"><span>[JBA+2010]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRank.exp" title="pymanopt.manifolds.psd.PSDFixedRank.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRank.point_layout" title="pymanopt.manifolds.psd.PSDFixedRank.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id47"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id48"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRank.typical_dist" title="pymanopt.manifolds.psd.PSDFixedRank.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRankComplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank Hermitian positive semidefinite (PSD) matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of rows and columns of a point in the ambient space.</p></li>
<li><p><strong>k</strong> – Rank of matrices in the ambient space.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A point <span class="math">\(\vmX\)</span> on the manifold is parameterized as <span class="math">\(\vmX =
\vmY\conj{\vmY}\)</span>, where <span class="math">\(\vmY\)</span> is a complex matrix of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span>
<span class="pre">k</span></code> and rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p>Tangent vectors are represented as matrices of the same shape as points
on the manifold.</p>
<p>For any point <span class="math">\(\vmY\)</span> on the manifold, given any complex unitary
matrix <span class="math">\(\vmU \in \C^{k \times k}\)</span>, we say
<span class="math">\(\vmY\vmU\)</span> is equivalent to <span class="math">\(\vmY\)</span> since <span class="math">\(\vmY\)</span>
and <span class="math">\(\vmY\vmU\)</span> are indistinguishable in the ambient space
<span class="math">\(\C^{n \times n}\)</span>, i.e., <span class="math">\(\vmX = \vmY\vmU\conj{(\vmY\vmU)} =
\vmY\conj{\vmY}\)</span>.
Therefore, the set of equivalence classes forms a Riemannian
quotient manifold <span class="math">\(\C^{n \times k} / \U(k)\)</span> where <span class="math">\(\U(k)\)</span>
denotes the unitary group.
The metric is the usual real trace inner product.</p>
<p>Notice that this manifold is not complete: if optimization leads points
to be rank-deficient, the geometry will break down.
Hence, this geometry should only be used if it is expected that the
points of interest will have rank exactly <code class="docutils literal notranslate"><span class="pre">k</span></code>.
Reduce <code class="docutils literal notranslate"><span class="pre">k</span></code> if that is not the case.</p>
<p>The implementation follows the quotient geometry originally described
in <a class="reference internal" href="bibliography.html#yat2013" id="id49"><span>[Yat2013]</span></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.exp" title="pymanopt.manifolds.psd.PSDFixedRankComplex.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.point_layout" title="pymanopt.manifolds.psd.PSDFixedRankComplex.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id50"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id51"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.typical_dist" title="pymanopt.manifolds.psd.PSDFixedRankComplex.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">Elliptope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>, <a class="reference internal" href="#pymanopt.manifolds.manifold.RetrAsExpMixin" title="pymanopt.manifolds.manifold.RetrAsExpMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RetrAsExpMixin</span></code></a></p>
<p>Manifold of fixed-rank PSD matrices with unit diagonal elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – Number of rows and columns of a point in the ambient space.</p></li>
<li><p><strong>k</strong> – Rank of matrices in the ambient space.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A point <span class="math">\(\vmX\)</span> on the manifold is parameterized as <span class="math">\(\vmX =
\vmY\transp{\vmY}\)</span> where <span class="math">\(\vmY\)</span> is a matrix of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">k</span></code> and
rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.
As such, <span class="math">\(\vmX\)</span> is symmetric, positive semidefinite with rank
<code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<p>Tangent vectors are represented as matrices of the same size as points
on the manifold so that tangent vectors in the ambient space are of the
form <span class="math">\(\dot{\vmX} = \vmY \transp{\dot{\vmY}} +
\dot{\vmY}\transp{\vmY}\)</span> and <span class="math">\(\dot{X}_{ii} = 0\)</span>.
The metric is the canonical Euclidean metric on <span class="math">\(\R^{n \times
k}\)</span>.</p>
<p>The diagonal constraints on <span class="math">\(X_{ii} = 1\)</span> translate to unit-norm
constraints on the rows of <span class="math">\(\vmY\)</span>: <span class="math">\(\norm{\vmy_i} = 1\)</span>
where <span class="math">\(\vmy_i\)</span> denotes the i-th column of <span class="math">\(\transp{\vmY}\)</span>.
Without any further restrictions, this coincides with the oblique
manifold (see <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique" title="pymanopt.manifolds.oblique.Oblique"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.oblique.Oblique</span></code></a>).
However, since for any orthogonal matrix <span class="math">\(\vmQ\)</span> of size <code class="docutils literal notranslate"><span class="pre">k</span></code>, it
holds that <span class="math">\(\vmY\vmQ\transp{(\vmY\vmQ)} = \vmY\transp{\vmY}\)</span>, we
“group” all matrices of the form <span class="math">\(\vmY\vmQ\)</span> in an equivalence
class.
This set of equivalence classes is a Riemannian quotient manifold that
is implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient points.
This does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient points, but convergence theorems
no longer hold.
As an alternative, you may try using the oblique manifold since it does
not break down at rank drop.</p>
<p>The geometry is taken from <a class="reference internal" href="bibliography.html#jba-2010" id="id52"><span>[JBA+2010]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.psd.Elliptope.typical_dist" title="pymanopt.manifolds.psd.Elliptope.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id53"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id54"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.psd.Elliptope.exp" title="pymanopt.manifolds.psd.Elliptope.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.psd.Elliptope.point_layout" title="pymanopt.manifolds.psd.Elliptope.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.fixed_rank">
<span id="fixed-rank-matrices"></span><h2>Fixed-Rank Matrices<a class="headerlink" href="#module-pymanopt.manifolds.fixed_rank" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.fixed_rank.</span></span><span class="sig-name descname"><span class="pre">FixedRankEmbedded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of fixed rank matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows of matrices in the ambient space.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns of matrices in the ambient space.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The rank of matrices.</p></li>
</ul>
</dd>
</dl>
<p>The manifold of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> real matrices of fixed rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.
For efficiency purposes, points on the manifold are represented with a
truncated singular value decomposition instead of full matrices of size <code class="docutils literal notranslate"><span class="pre">m</span>
<span class="pre">x</span> <span class="pre">n</span></code>.
Specifically, a point is represented as a tuple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">s,</span> <span class="pre">vt)</span></code> of three
arrays.
The arrays <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">vt</span></code> have shapes <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">k)</span></code>, <code class="docutils literal notranslate"><span class="pre">(k,)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n)</span></code>, respectively, and the rank <code class="docutils literal notranslate"><span class="pre">k</span></code> matrix which they represent
can be recovered by the product <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">np.diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vt</span></code>.</p>
<p>Vectors <code class="docutils literal notranslate"><span class="pre">Z</span></code> in the ambient space are best represented as arrays of shape
<code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>.
If these are low-rank, they may also be represented as tuples of arrays
<code class="docutils literal notranslate"><span class="pre">(U,</span> <span class="pre">S,</span> <span class="pre">V)</span></code> such that <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">&#64;</span> <span class="pre">S</span> <span class="pre">&#64;</span> <span class="pre">V.T</span></code>.
There are no restrictions on what <code class="docutils literal notranslate"><span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> are, as long as
their product as indicated yields a real <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix.</p>
<p>Tangent vectors are represented as tuples of the form <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code>.
The matrices <code class="docutils literal notranslate"><span class="pre">Up</span></code> (of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">k</span></code>) and <code class="docutils literal notranslate"><span class="pre">Vp</span></code> (of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">k</span></code>) obey
the conditions <code class="docutils literal notranslate"><span class="pre">np.allclose(Up.T</span> <span class="pre">&#64;</span> <span class="pre">U,</span> <span class="pre">0)</span></code> and <code class="docutils literal notranslate"><span class="pre">np.allclose(Vp.T</span> <span class="pre">&#64;</span> <span class="pre">V,</span>
<span class="pre">0)</span></code>.
The matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> (of size <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">k</span></code>) is arbitrary.
Such a structure corresponds to the tangent vector <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">M</span> <span class="pre">&#64;</span> <span class="pre">vt</span> <span class="pre">+</span> <span class="pre">Up</span> <span class="pre">&#64;</span>
<span class="pre">vt</span> <span class="pre">+</span> <span class="pre">u</span> <span class="pre">*</span> <span class="pre">Vp.T</span></code> in the ambient space of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices at a point <code class="docutils literal notranslate"><span class="pre">(u,</span>
<span class="pre">s,</span> <span class="pre">vt)</span></code>.</p>
<p>The chosen geometry yields a Riemannian submanifold of the embedding
space <span class="math">\(\R^{m \times n}\)</span> equipped with the usual trace inner product.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The implementation follows the embedded geometry described in
<a class="reference internal" href="bibliography.html#van2013" id="id55"><span>[Van2013]</span></a>.</p></li>
<li><p>The class is currently not compatible with the
<a class="reference internal" href="optimizers.html#pymanopt.optimizers.trust_regions.TrustRegions" title="pymanopt.optimizers.trust_regions.TrustRegions"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.optimizers.trust_regions.TrustRegions</span></code></a> optimizer.</p></li>
<li><p>Details on the implementation of
<a class="reference internal" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient" title="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_gradient()</span></code></a> can be found at
<a class="reference external" href="https://j-towns.github.io/papers/svd-derivative.pdf">https://j-towns.github.io/papers/svd-derivative.pdf</a>.</p></li>
<li><p>The second-order retraction follows results presented in <a class="reference internal" href="bibliography.html#am2012" id="id56"><span>[AM2012]</span></a>.</p></li>
</ul>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist" title="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.projection" title="Permalink to this definition"></a></dt>
<dd><p>Project vector in the ambient space to the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector parameterized as a <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">vector</span></code> must either be an array of shape <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>
in the ambient space, or else a tuple <code class="docutils literal notranslate"><span class="pre">(U,</span> <span class="pre">S,</span> <span class="pre">V)</span></code> where <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#64;</span> <span class="pre">S</span> <span class="pre">&#64;</span>
<span class="pre">V</span></code> is in the ambient space (of low-rank matrices).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id57"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id58"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.exp" title="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.point_layout" title="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>normal_vector</strong> – A vector orthogonal to the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.positive">
<span id="positive-matrices"></span><h2>Positive Matrices<a class="headerlink" href="#module-pymanopt.manifolds.positive" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.positive.</span></span><span class="sig-name descname"><span class="pre">Positive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_parallel_transport</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>The (product) manifold of positive matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of matrices in the product.</p></li>
<li><p><strong>use_parallel_transport</strong> (<em>bool</em>) – Flag whether to use a parallel transport for
<a class="reference internal" href="#pymanopt.manifolds.positive.Positive.transport" title="pymanopt.manifolds.positive.Positive.transport"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport()</span></code></a> or a transporter (the default).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Points on the manifold are represented as arrays of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>
(when <code class="docutils literal notranslate"><span class="pre">k</span></code> is 1), and <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> otherwise.</p>
<p>The tangent spaces of the manifold correspond to copies of <span class="math">\(\R^{m
\times n}\)</span>.
As such, tangent vectors are represented as arrays of the same shape as
points on the manifold without any positivity constraints on the
individual elements.</p>
<p>The Riemannian metric is the bi-invariant metric for positive definite
matrices from chapter 6 of <a class="reference internal" href="bibliography.html#bha2007" id="id59"><span>[Bha2007]</span></a> on individual scalar coordinates
of matrices.
See also section 11.4 of <a class="reference internal" href="bibliography.html#bou2020" id="id60"><span>[Bou2020]</span></a> for further details.</p>
<p>The second-order retraction is taken from <a class="reference internal" href="bibliography.html#jvv2012" id="id61"><span>[JVV2012]</span></a>.</p>
<p>The parallel transport that is used when <code class="docutils literal notranslate"><span class="pre">use_parallel_transport</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> is taken from <a class="reference internal" href="bibliography.html#sh2015" id="id62"><span>[SH2015]</span></a>.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.positive.Positive.typical_dist" title="pymanopt.manifolds.positive.Positive.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.positive.Positive.exp" title="pymanopt.manifolds.positive.Positive.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.positive.Positive.point_layout" title="pymanopt.manifolds.positive.Positive.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id63"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id64"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.hyperbolic">
<span id="hyperbolic-space"></span><h2>Hyperbolic Space<a class="headerlink" href="#module-pymanopt.manifolds.hyperbolic" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.hyperbolic.</span></span><span class="sig-name descname"><span class="pre">PoincareBall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>The Poincare ball.</p>
<p>The Poincare ball of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>.
Elements are represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(n,)</span></code> if <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">=</span> <span class="pre">1</span></code>.
For <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, the class represents the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> Poincare
balls of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>, in which case points are represented as arrays of
shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n)</span></code>.</p>
<p>Since the manifold is open, the tangent space at every point is a copy of
<span class="math">\(\R^n\)</span>.</p>
<p>The Poincare ball is embedded in <span class="math">\(\R^n\)</span> and is a Riemannian manifold,
but it is not an embedded Riemannian submanifold since the metric is not
inherited from the Euclidean inner product of its ambient space.
Instead, the Riemannian metric is conformal to the Euclidean one (angles are
preserved), and it is given at every point <span class="math">\(\vmx\)</span> by
<span class="math">\(\inner{\vmu}{\vmv}_\vmx = \lambda_\vmx^2 \inner{\vmu}{\vmv}\)</span> where
<span class="math">\(\lambda_\vmx = 2 / (1 - \norm{\vmx}^2)\)</span> is the conformal factor.
This induces the following distance between two points <span class="math">\(\vmx\)</span> and
<span class="math">\(\vmy\)</span> on the manifold:</p>
<blockquote>
<div><p><span class="math">\(\dist_\manM(\vmx, \vmy) = \arccosh\parens{1 + 2 \frac{\norm{\vmx
- \vmy}^2}{(1 - \norm{\vmx}^2) (1 - \norm{\vmy}^2)}}.\)</span></p>
</div></blockquote>
<p>The norm here is understood as the Euclidean norm in the ambient space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The dimension of the Poincare ball.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of elements in the product of Poincare balls.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.hyperbolic.PoincareBall.typical_dist" title="pymanopt.manifolds.hyperbolic.PoincareBall.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.hyperbolic.PoincareBall.exp" title="pymanopt.manifolds.hyperbolic.PoincareBall.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.mobius_addition">
<span class="sig-name descname"><span class="pre">mobius_addition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.mobius_addition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.mobius_addition" title="Permalink to this definition"></a></dt>
<dd><p>Möbius addition.</p>
<p>Special non-associative and non-commutative operation which is closed
in the Poincare ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point.</p></li>
<li><p><strong>point_b</strong> – The second point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Möbius sum of <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.conformal_factor">
<span class="sig-name descname"><span class="pre">conformal_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/hyperbolic.html#PoincareBall.conformal_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.conformal_factor" title="Permalink to this definition"></a></dt>
<dd><p>The conformal factor for a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – The point for which to compute the conformal factor.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The conformal factor.
If <code class="docutils literal notranslate"><span class="pre">point</span></code> is a point on the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> Poincare
balls, the return value will be an array of shape <code class="docutils literal notranslate"><span class="pre">(k,1)</span></code>.
The singleton dimension is explicitly kept to simplify
multiplication of <code class="docutils literal notranslate"><span class="pre">point</span></code> by the conformal factor on product
manifolds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.hyperbolic.PoincareBall.point_layout" title="pymanopt.manifolds.hyperbolic.PoincareBall.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.hyperbolic.PoincareBall.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.hyperbolic.PoincareBall.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id65"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id66"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.product">
<span id="product-manifold"></span><h2>Product Manifold<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.product.</span></span><span class="sig-name descname"><span class="pre">Product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifolds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Cartesian product manifold.</p>
<p>Points on the manifold and tangent vectors are represented as lists of
points and tangent vectors of the individual manifolds.
The metric is obtained by element-wise extension of the individual
manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>manifolds</strong> (<em>Sequence</em><em>[</em><a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><em>pymanopt.manifolds.manifold.Manifold</em></a><em>]</em>) – The collection of manifolds in the product.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.product.Product.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – If no <a class="reference internal" href="#pymanopt.manifolds.product.Product.typical_dist" title="pymanopt.manifolds.product.Product.typical_dist"><code class="xref py py-attr docutils literal notranslate"><span class="pre">typical_dist</span></code></a> is defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The norm of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The distance between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector in the ambient space of the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An element of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>
in the ambient space.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to a call to meth:<cite>projection</cite> but
may differ for certain manifolds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>vector</strong> – A vector close to the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code> closest to <code class="docutils literal notranslate"><span class="pre">vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient as a vector in the
ambient space of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.
This must be a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function
at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the
Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">point</span></code> along <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The point on the manifold at which the Euclidean gradient
and Hessian was evaluated.</p></li>
<li><p><strong>euclidean_gradient</strong> – The Euclidean gradient at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
<li><p><strong>euclidean_hessian</strong> – The Euclidean Hessian at <code class="docutils literal notranslate"><span class="pre">point</span></code> along the
direction <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p></li>
<li><p><strong>tangent_vector</strong> – The tangent vector in the direction of which the
Riemannian Hessian is to be calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Riemannian Hessian as a tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code>
along a geodesic in the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the manifold reached by moving away from <code class="docutils literal notranslate"><span class="pre">point</span></code> in
the direction of <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.product.Product.exp" title="pymanopt.manifolds.product.Product.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – First point on the manifold.</p></li>
<li><p><strong>point_b</strong> – Second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A randomly chosen point on the manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A randomly chosen tangent vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id67"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id68"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
<li><p><strong>tangent_vector_a</strong> – The tangent vector at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> to transport to
the tangent space at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tangent vector at <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code> on
the manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">point_b</span></code> on the geodesic arc joining them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_a</strong> – The first point on the manifold.</p></li>
<li><p><strong>point_b</strong> – The second point on the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The mid-way point between <code class="docutils literal notranslate"><span class="pre">point_a</span></code> and <code class="docutils literal notranslate"><span class="pre">point_b</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> – A point on the manifold.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The origin of the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.product.Product.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.product.Product.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Convert tangent vector to ambient space representation.</p>
<p>Certain manifolds represent tangent vectors in a format that is more
convenient for numerical calculations than their representation in the
ambient space.
Euclidean Hessian operators generally expect tangent vectors in their
ambient space representation though.
This method allows switching between the two possible representations,
For most manifolds, <code class="docutils literal notranslate"><span class="pre">embedding</span></code> is simply the identity map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – A point on the manifold.</p></li>
<li><p><strong>tangent_vector</strong> – A tangent vector in the internal representation of
the manifold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The same tangent vector in the ambient space representation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is mainly needed internally by the
<a class="reference internal" href="problem.html#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> class in order to convert
tangent vectors to the representation expected by user-given or
autodiff-generated Euclidean Hessian operators.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#pymanopt.manifolds.product.Product.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.product.Product.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <a class="reference internal" href="#pymanopt.manifolds.product.Product.point_layout" title="pymanopt.manifolds.product.Product.point_layout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">point_layout</span></code></a> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api-reference.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="autodiff.html" class="btn btn-neutral float-right" title="Automatic Differentiation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, Jamie Townsend, Niklas Koep, Sebastian Weichwald.
      <span class="lastupdated">Last updated on Apr 02, 2023.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: stable
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/docs/stable">stable</a></dd>
      <dd><a href="/docs/latest">latest</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>