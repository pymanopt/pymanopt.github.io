

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymanopt. &mdash; Pymanopt dev documentation</title>
    
    <link rel="stylesheet" href="_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/bizstyle.js"></script>
    <link rel="top" title="Pymanopt dev documentation" href="#" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Pymanopt dev documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pymanopt.</a><ul>
<li><a class="reference internal" href="#core">core.</a><ul>
<li><a class="reference internal" href="#module-pymanopt.core.problem">problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#manifolds">manifolds.</a><ul>
<li><a class="reference internal" href="#module-pymanopt.manifolds.manifold">manifold (abc)</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.euclidean">euclidean</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">grassmann</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.oblique">oblique</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.product">product</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.psd">psd</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.sphere">sphere</a></li>
<li><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">stiefel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#solvers">solvers.</a><ul>
<li><a class="reference internal" href="#module-pymanopt.solvers.solver">solver (abc)</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.conjugate_gradient">conjugate_gradient</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.linesearch">linesearch</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.nelder_mead">nelder_mead</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.particle_swarm">particle_swarm</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.steepest_descent">steepest_descent</a></li>
<li><a class="reference internal" href="#module-pymanopt.solvers.trust_regions">trust_regions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tools">tools.</a><ul>
<li><a class="reference internal" href="#module-pymanopt.tools.autodiff">autodiff</a></li>
<li><a class="reference internal" href="#module-pymanopt.tools.multi">multi</a></li>
<li><a class="reference internal" href="#module-pymanopt.tools.testing">testing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pymanopt">
<h1>pymanopt.<a class="headerlink" href="#pymanopt" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core">
<h2>core.<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.core.problem">
<span id="problem"></span><h3>problem<a class="headerlink" href="#module-pymanopt.core.problem" title="Permalink to this headline">¶</a></h3>
<p>Module containing pymanopt problem class. Use this to build a problem
object to feed to one of the solvers.</p>
<dl class="class">
<dt id="pymanopt.core.problem.Problem">
<em class="property">class </em><code class="descclassname">pymanopt.core.problem.</code><code class="descname">Problem</code><span class="sig-paren">(</span><em>manifold</em>, <em>cost</em>, <em>egrad=None</em>, <em>ehess=None</em>, <em>grad=None</em>, <em>hess=None</em>, <em>arg=None</em>, <em>precon=None</em>, <em>verbosity=2</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.core.problem.Problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Problem class for setting up a problem to feed to one of the
pymanopt solvers.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>manifold</dt>
<dd><p class="first last">Manifold to optimize over.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cost</dt>
<dd><p class="first last">A callable which takes an element of manifold and returns a
real number, or a symbolic Theano or TensorFlow expression.
In case of a symbolic expression, the gradient (and if
necessary the Hessian) are computed automatically if they are
not explicitly given. We recommend you take this approach
rather than calculating gradients and Hessians by hand.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>grad</dt>
<dd><p class="first last">grad(x) is the gradient of cost at x. This must take an
element X of manifold and return an element of the tangent space
to manifold at X. This is usually computed automatically and
doesn&#8217;t need to be set by the user.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hess</dt>
<dd><p class="first last">hess(x, a) is the directional derivative of grad at x, in
direction a. It should return an element of the tangent
space to manifold at x.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>egrad</dt>
<dd><p class="first last">The &#8216;Euclidean gradient&#8217;, egrad(x) should return the grad of
cost in the usual sense, i.e. egrad(x) need not lie in the
tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ehess</dt>
<dd><p class="first last">The &#8216;Euclidean Hessian&#8217;, ehess(x, a) should return the
directional derivative of egrad at x in direction a. This
need not lie in the tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>arg</dt>
<dd><p class="first last">A symbolic (tensor) variable with respect to which you would like
to optimize. Its type (together with the type of the cost argument)
defines the autodiff backend used.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>verbosity (2)</dt>
<dd><p class="first last">Level of information printed by the solver while it operates, 0
is silent, 2 is most information.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.backend">
<code class="descname">backend</code><a class="headerlink" href="#pymanopt.core.problem.Problem.backend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.cost">
<code class="descname">cost</code><a class="headerlink" href="#pymanopt.core.problem.Problem.cost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.egrad">
<code class="descname">egrad</code><a class="headerlink" href="#pymanopt.core.problem.Problem.egrad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.ehess">
<code class="descname">ehess</code><a class="headerlink" href="#pymanopt.core.problem.Problem.ehess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.grad">
<code class="descname">grad</code><a class="headerlink" href="#pymanopt.core.problem.Problem.grad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.core.problem.Problem.hess">
<code class="descname">hess</code><a class="headerlink" href="#pymanopt.core.problem.Problem.hess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="manifolds">
<h2>manifolds.<a class="headerlink" href="#manifolds" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.manifolds.manifold">
<span id="manifold-abc"></span><h3>manifold (abc)<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.manifold.Manifold">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.manifold.</code><code class="descname">Manifold</code><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract base class setting out template for manifold classes.</p>
<dl class="attribute">
<dt id="pymanopt.manifolds.manifold.Manifold.dim">
<code class="descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.dist">
<code class="descname">dist</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.egrad2rgrad">
<code class="descname">egrad2rgrad</code><span class="sig-paren">(</span><em>X</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.ehess2rhess">
<code class="descname">ehess2rhess</code><span class="sig-paren">(</span><em>X</em>, <em>Hess</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.exp">
<code class="descname">exp</code><span class="sig-paren">(</span><em>X</em>, <em>U</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.inner">
<code class="descname">inner</code><span class="sig-paren">(</span><em>X</em>, <em>G</em>, <em>H</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>X</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.pairmean">
<code class="descname">pairmean</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.proj">
<code class="descname">proj</code><span class="sig-paren">(</span><em>X</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.rand">
<code class="descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.randvec">
<code class="descname">randvec</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.retr">
<code class="descname">retr</code><span class="sig-paren">(</span><em>X</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.transp">
<code class="descname">transp</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymanopt.manifolds.manifold.Manifold.typicaldist">
<code class="descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8220;scale&#8221; of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.zerovec">
<code class="descname">zerovec</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zerovec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero tangent vector at X.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.euclidean">
<span id="euclidean"></span><h3>euclidean<a class="headerlink" href="#module-pymanopt.manifolds.euclidean" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.euclidean.</code><code class="descname">Euclidean</code><span class="sig-paren">(</span><em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Euclidean manifold, i.e. the euclidean space of m-by-n matrices
equipped with the Frobenius distance and trace inner product.
Use for solving unconstrained problems with pymanopt.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.grassmann">
<span id="grassmann"></span><h3>grassmann<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.grassmann.</code><code class="descname">Grassmann</code><span class="sig-paren">(</span><em>height</em>, <em>width</em>, <em>k=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Factory class for the Grassmann manifold. This is the manifold of p-
dimensional subspaces of n dimensional real vector space. Initiation
requires the dimensions n, p to be specified. Optional argument k
allows the user to optimize over the product of k Grassmanns.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.oblique">
<span id="oblique"></span><h3>oblique<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.oblique.Oblique">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.oblique.</code><code class="descname">Oblique</code><span class="sig-paren">(</span><em>m</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of matrices w/ unit-norm columns.</p>
<p>Oblique manifold: deals with matrices of size m-by-n such that each column
has unit 2-norm, i.e., is a point on the unit sphere in R^m. The metric
is such that the oblique manifold is a Riemannian submanifold of the
space of m-by-n matrices with the usual trace inner product, i.e., the
usual metric.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.product">
<span id="product"></span><h3>product<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.product.Product">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.product.</code><code class="descname">Product</code><span class="sig-paren">(</span><em>manifolds</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Product manifold, i.e. the cartesian product of multiple manifolds.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.psd">
<span id="psd"></span><h3>psd<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.psd.Elliptope">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.psd.</code><code class="descname">Elliptope</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of n-by-n psd matrices of rank k with unit diagonal elements.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y&#8217;s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may be
big). Tangent vectors are represented as matrices of the same size as Y,
call them Ydot, so that Xdot = Y Ydot&#8217; + Ydot Y and diag(Xdot) == 0. The
metric is the canonical Euclidean metric on Y.</p>
<p>The diagonal constraints on X (X(i, i) == 1 for all i) translate to
unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.  The
set of such Y&#8217;s forms the oblique manifold. But because for any orthogonal
Q of size k, it holds that (YQ)(YQ)&#8217; = YY&#8217;, we &#8220;group&#8221; all matrices of the
form YQ in an equivalence class. The set of equivalence classes is a
Riemannian quotient manifold, implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient Y&#8217;s.  This
does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient Y&#8217;s, but convergence theorems no
longer hold. As an alternative, you may use the oblique manifold (it has
larger dimension, but does not break down at rank drop.)</p>
<p>The geometry is taken from the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
&#8220;Low-Rank Optimization on the Cone of Positive Semidefinite Matrices&#8221;.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.psd.</code><code class="descname">PSDFixedRank</code><span class="sig-paren">(</span><em>n</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of n-by-n symmetric positive semidefinite matrices of rank k.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y&#8217;s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may
be big). Tangent vectors are represented as matrices of the same size as
Y, call them Ydot, so that Xdot = Y Ydot&#8217; + Ydot Y. The metric is the
canonical Euclidean metric on Y.</p>
<p>Since for any orthogonal Q of size k, it holds that (YQ)(YQ)&#8217; = YY&#8217;,
we &#8220;group&#8221; all matrices of the form YQ in an equivalence class. The set
of equivalence classes is a Riemannian quotient manifold, implemented
here.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<p>An alternative, complete, geometry for positive semidefinite matrices of
rank k is described in Bonnabel and Sepulchre 2009, &#8220;Riemannian Metric
and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank&#8221;,
SIAM Journal on Matrix Analysis and Applications.</p>
<p>The geometry implemented here is the simplest case of the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
&#8220;Low-Rank Optimization on the Cone of Positive Semidefinite Matrices&#8221;.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.psd.</code><code class="descname">PSDFixedRankComplex</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRank" title="pymanopt.manifolds.psd.PSDFixedRank"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.psd.PSDFixedRank</span></code></a></p>
<p>Manifold of n x n complex Hermitian pos. semidefinite matrices of rank k.</p>
<p>Manifold of n-by-n complex Hermitian positive semidefinite matrices of
fixed rank k. This follows the quotient geometry described
in Sarod Yatawatta&#8217;s 2013 paper:
&#8220;Radio interferometric calibration using a Riemannian manifold&#8221;, ICASSP.</p>
<p>Paper link: <a class="reference external" href="http://dx.doi.org/10.1109/ICASSP.2013.6638382">http://dx.doi.org/10.1109/ICASSP.2013.6638382</a>.</p>
<p>A point X on the manifold M is parameterized as YY^*, where
Y is a complex matrix of size nxk. For any point Y on the manifold M,
given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y,
i.e., YY^* does not change. Therefore, M is the set of equivalence
classes and is a Riemannian quotient manifold C^{nk}/SU(k).
The metric is the usual real-trace inner product, that is,
it is the usual metric for the complex plane identified with R^2.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PositiveDefinite">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.psd.</code><code class="descname">PositiveDefinite</code><span class="sig-paren">(</span><em>n</em>, <em>k=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of (n x n)^k positive definite matrices, based on the geometry
discussed in Chapter 6 of Positive Definite Matrices (Bhatia 2007). Some
of the implementation is based on sympositivedefinitefactory.m from the
Manopt MATLAB package. Also see &#8220;Conic geometric optimisation on the
manifold of positive definite matrices&#8221; (Sra &amp; Hosseini 2013) for more
details.</p>
<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.pairmean">
<code class="descname">pairmean</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.sphere">
<span id="sphere"></span><h3>sphere<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.sphere.Sphere">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.sphere.</code><code class="descname">Sphere</code><span class="sig-paren">(</span><em>m</em>, <em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of m-by-n real matrices of unit Frobenius norm. By default, n =
1, which corresponds to the unit sphere in R^m. The metric is such that the
sphere is a Riemannian submanifold of the space of m-by-n matrices with the
usual trace inner product, i.e., the usual metric.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.stiefel">
<span id="stiefel"></span><h3>stiefel<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property">class </em><code class="descclassname">pymanopt.manifolds.stiefel.</code><code class="descname">Stiefel</code><span class="sig-paren">(</span><em>height</em>, <em>width</em>, <em>k=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Factory class for the Stiefel manifold. Initiation requires the dimensions
n, p to be specified. Optional argument k allows the user to optimize over
the product of k Stiefels.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
</dd></dl>

</div>
</div>
<div class="section" id="solvers">
<h2>solvers.<a class="headerlink" href="#solvers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.solvers.solver">
<span id="solver-abc"></span><h3>solver (abc)<a class="headerlink" href="#module-pymanopt.solvers.solver" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.solver.Solver">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.solver.</code><code class="descname">Solver</code><span class="sig-paren">(</span><em>maxtime=1000</em>, <em>maxiter=1000</em>, <em>mingradnorm=1e-06</em>, <em>minstepsize=1e-10</em>, <em>maxcostevals=5000</em>, <em>logverbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.solver.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract base class setting out template for solver classes.</p>
<dl class="method">
<dt id="pymanopt.solvers.solver.Solver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.solver.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the given problem (starting from a random initial guess if
the optional argument x is not provided)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.conjugate_gradient">
<span id="conjugate-gradient"></span><h3>conjugate_gradient<a class="headerlink" href="#module-pymanopt.solvers.conjugate_gradient" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.conjugate_gradient.ConjugateGradient">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.conjugate_gradient.</code><code class="descname">ConjugateGradient</code><span class="sig-paren">(</span><em>beta_type=2</em>, <em>orth_value=inf</em>, <em>linesearch=&lt;pymanopt.solvers.linesearch.LineSearchAdaptive object&gt;</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Module containing conjugate gradient algorithm based on
conjugategradient.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using nonlinear conjugate gradient method with
linesearch.
This method first computes the gradient of obj w.r.t. arg, and then
optimizes by moving in a direction that is conjugate to all previous
search directions.
Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>problem</dt>
<dd><p class="first last">Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x=None</dt>
<dd><p class="first last">Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>x</dt>
<dd><p class="first last">Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.linesearch">
<span id="linesearch"></span><h3>linesearch<a class="headerlink" href="#module-pymanopt.solvers.linesearch" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.linesearch.LineSearchAdaptive">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.linesearch.</code><code class="descname">LineSearchAdaptive</code><span class="sig-paren">(</span><em>contraction_factor=0.5</em>, <em>suff_decr=0.5</em>, <em>maxiter=10</em>, <em>initial_stepsize=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Adaptive line-search</p>
<dl class="method">
<dt id="pymanopt.solvers.linesearch.LineSearchAdaptive.search">
<code class="descname">search</code><span class="sig-paren">(</span><em>objective</em>, <em>man</em>, <em>x</em>, <em>d</em>, <em>f0</em>, <em>df0</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive.search" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.solvers.linesearch.LineSearchBackTracking">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.linesearch.</code><code class="descname">LineSearchBackTracking</code><span class="sig-paren">(</span><em>contraction_factor=0.5</em>, <em>optimism=2</em>, <em>suff_decr=0.0001</em>, <em>maxiter=25</em>, <em>initial_stepsize=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Back-tracking line-search based on linesearch.m in the manopt MATLAB
package.</p>
<dl class="method">
<dt id="pymanopt.solvers.linesearch.LineSearchBackTracking.search">
<code class="descname">search</code><span class="sig-paren">(</span><em>objective</em>, <em>manifold</em>, <em>x</em>, <em>d</em>, <em>f0</em>, <em>df0</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to perform backtracking line-search.
Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>objective</dt>
<dd><p class="first last">objective function to optimise</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>manifold</dt>
<dd><p class="first last">manifold to optimise over</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x</dt>
<dd><p class="first last">starting point on the manifold</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>d</dt>
<dd><p class="first last">tangent vector at x (descent direction)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>df0</dt>
<dd><p class="first last">directional derivative at x along d</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>stepsize</dt>
<dd><p class="first last">norm of the vector retracted to reach newx from x</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>newx</dt>
<dd><p class="first last">next iterate suggested by the line-search</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.nelder_mead">
<span id="nelder-mead"></span><h3>nelder_mead<a class="headerlink" href="#module-pymanopt.solvers.nelder_mead" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.nelder_mead.NelderMead">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.nelder_mead.</code><code class="descname">NelderMead</code><span class="sig-paren">(</span><em>maxcostevals=None</em>, <em>maxiter=None</em>, <em>reflection=1</em>, <em>expansion=2</em>, <em>contraction=0.5</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Nelder-Mead minimization alglorithm for derivative-free minimization
based on neldermead.m and centroid.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.nelder_mead.NelderMead.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using a Nelder-Mead minimization algorithm.
Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>problem</dt>
<dd><p class="first last">Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x=None</dt>
<dd><p class="first last">Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>x</dt>
<dd><p class="first last">Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymanopt.solvers.nelder_mead.compute_centroid">
<code class="descclassname">pymanopt.solvers.nelder_mead.</code><code class="descname">compute_centroid</code><span class="sig-paren">(</span><em>man</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.nelder_mead.compute_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the centroid as Karcher mean of points x belonging to the manifold
man.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.particle_swarm">
<span id="particle-swarm"></span><h3>particle_swarm<a class="headerlink" href="#module-pymanopt.solvers.particle_swarm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.particle_swarm.ParticleSwarm">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.particle_swarm.</code><code class="descname">ParticleSwarm</code><span class="sig-paren">(</span><em>maxcostevals=None</em>, <em>maxiter=None</em>, <em>populationsize=None</em>, <em>nostalgia=1.4</em>, <em>social=1.4</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Particle swarm optimization method based on pso.m from the manopt
MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.particle_swarm.ParticleSwarm.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using the particle swarm optimization algorithm.
Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>problem</dt>
<dd><p class="first last">Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost (specified using a theano graph
or as a python function).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x=None</dt>
<dd><p class="first last">Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>x</dt>
<dd><p class="first last">Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.steepest_descent">
<span id="steepest-descent"></span><h3>steepest_descent<a class="headerlink" href="#module-pymanopt.solvers.steepest_descent" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.steepest_descent.SteepestDescent">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.steepest_descent.</code><code class="descname">SteepestDescent</code><span class="sig-paren">(</span><em>linesearch=&lt;pymanopt.solvers.linesearch.LineSearchBackTracking object&gt;</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Steepest descent (gradient descent) algorithm based on
steepestdescent.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.steepest_descent.SteepestDescent.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using gradient descent with linesearch.
This method first computes the gradient (derivative) of obj
w.r.t. arg, and then optimizes by moving in the direction of
steepest descent (which is the opposite direction to the gradient).
Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>problem</dt>
<dd><p class="first last">Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x=None</dt>
<dd><p class="first last">Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>x</dt>
<dd><p class="first last">Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.trust_regions">
<span id="trust-regions"></span><h3>trust_regions<a class="headerlink" href="#module-pymanopt.solvers.trust_regions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.trust_regions.TrustRegions">
<em class="property">class </em><code class="descclassname">pymanopt.solvers.trust_regions.</code><code class="descname">TrustRegions</code><span class="sig-paren">(</span><em>miniter=3</em>, <em>kappa=0.1</em>, <em>theta=1.0</em>, <em>rho_prime=0.1</em>, <em>use_rand=False</em>, <em>rho_regularization=1000.0</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR">
<code class="descname">EXCEEDED_TR</code><em class="property"> = 1</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER">
<code class="descname">MAX_INNER_ITER</code><em class="property"> = 4</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED">
<code class="descname">MODEL_INCREASED</code><em class="property"> = 5</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE">
<code class="descname">NEGATIVE_CURVATURE</code><em class="property"> = 0</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR">
<code class="descname">REACHED_TARGET_LINEAR</code><em class="property"> = 2</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR">
<code class="descname">REACHED_TARGET_SUPERLINEAR</code><em class="property"> = 3</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS">
<code class="descname">TCG_STOP_REASONS</code><em class="property"> = {0: 'negative curvature', 1: 'exceeded trust region', 2: 'reached target residual-kappa (linear)', 3: 'reached target residual-theta (superlinear)', 4: 'maximum inner iterations', 5: 'model increased'}</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>problem</em>, <em>x=None</em>, <em>mininner=1</em>, <em>maxinner=None</em>, <em>Delta_bar=None</em>, <em>Delta0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="tools">
<h2>tools.<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.tools.autodiff">
<span id="autodiff"></span><h3>autodiff<a class="headerlink" href="#module-pymanopt.tools.autodiff" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.tools.autodiff.TheanoBackend">
<em class="property">class </em><code class="descclassname">pymanopt.tools.autodiff.</code><code class="descname">TheanoBackend</code><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pymanopt.tools.autodiff._backend.Backend</span></code></p>
<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compile_function">
<code class="descname">compile_function</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compile_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for the theano.function(). Compiles a theano graph into a
python function.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compute_gradient">
<code class="descname">compute_gradient</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compute_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for theano.tensor.grad(). Computes the gradient of &#8216;objective&#8217;
with respect to &#8216;argument&#8217; and returns compiled version.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compute_hessian">
<code class="descname">compute_hessian</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the directional derivative of the gradient (which is equal to
the Hessian multiplied by direction).</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.is_available">
<code class="descname">is_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.is_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.is_compatible">
<code class="descname">is_compatible</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.tools.autodiff.AutogradBackend">
<em class="property">class </em><code class="descclassname">pymanopt.tools.autodiff.</code><code class="descname">AutogradBackend</code><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pymanopt.tools.autodiff._backend.Backend</span></code></p>
<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.compute_gradient">
<code class="descname">compute_gradient</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.compute_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of &#8216;objective&#8217; with respect to the first
argument and return as a function.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.compute_hessian">
<code class="descname">compute_hessian</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.is_available">
<code class="descname">is_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.is_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.is_compatible">
<code class="descname">is_compatible</code><span class="sig-paren">(</span><em>backend</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.tools.multi">
<span id="multi"></span><h3>multi<a class="headerlink" href="#module-pymanopt.tools.multi" title="Permalink to this headline">¶</a></h3>
<p>Operations on multiple matrices.</p>
<dl class="function">
<dt id="pymanopt.tools.multi.multiexp">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multiexp</code><span class="sig-paren">(</span><em>A</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multiexp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multieye">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multieye</code><span class="sig-paren">(</span><em>k</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multieye" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multilog">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multilog</code><span class="sig-paren">(</span><em>A</em>, <em>pos_def=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multilog" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multiprod">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multiprod</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multiprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspired by MATLAB multiprod function by Paolo de Leva. A and B are
assumed to be arrays containing M matrices, that is, A and B have
dimensions A: (M, N, P), B:(M, P, Q). multiprod multiplies each matrix
in A with the corresponding matrix in B, using matrix multiplication.
so multiprod(A, B) has dimensions (M, N, Q).</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multisym">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multisym</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multisym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multitransp">
<code class="descclassname">pymanopt.tools.multi.</code><code class="descname">multitransp</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.multi.multitransp" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspired by MATLAB multitransp function by Paolo de Leva. A is assumed to
be an array containing M matrices, each of which has dimension N x P.
That is, A is an M x N x P array. Multitransp then returns an array
containing the M matrix transposes of the matrices in A, each of which
will be P x N.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.tools.testing">
<span id="testing"></span><h3>testing<a class="headerlink" href="#module-pymanopt.tools.testing" title="Permalink to this headline">¶</a></h3>
<p>Module containing tools for testing correctness in Pymanopt. Note, these
currently require autograd.</p>
<p>Note: the methods for generating rgrad, egrad2rgrad, ehess and ehess2rhess
will only be correct if the manifold is a submanifold of Euclidean space,
that is if the projection is an orthogonal projection onto the tangent space.</p>
<dl class="function">
<dt id="pymanopt.tools.testing.egrad2rgrad">
<code class="descclassname">pymanopt.tools.testing.</code><code class="descname">egrad2rgrad</code><span class="sig-paren">(</span><em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.testing.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an egrad2rgrad function.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.ehess2rhess">
<code class="descclassname">pymanopt.tools.testing.</code><code class="descname">ehess2rhess</code><span class="sig-paren">(</span><em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.testing.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an ehess2rhess function for a manifold which is a sub-manifold
of Euclidean space.
ehess2rhess(proj)(x, egrad, ehess, u) converts the Euclidean hessian ehess
at the point x to a Riemannian hessian. That is the directional
derivatative of the gradient in the direction u.
proj must be defined using autograd.numpy.
This will not be an efficient implementation because of missing support
for efficient jacobian-vector products in autograd.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.rgrad">
<code class="descclassname">pymanopt.tools.testing.</code><code class="descname">rgrad</code><span class="sig-paren">(</span><em>cost</em>, <em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.testing.rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Riemannain gradient of cost. Cost must be defined using
autograd.numpy.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.rhess">
<code class="descclassname">pymanopt.tools.testing.</code><code class="descname">rhess</code><span class="sig-paren">(</span><em>cost</em>, <em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.tools.testing.rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Riemannian hessian of the cost. Specifically, rhess(cost,
proj)(x, u) is the directional derivatative of cost at point X on the
manifold, in direction u.
cost and proj must be defined using autograd.numpy.
See <a class="reference external" href="http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf">http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf</a>
for some discussion.
proj and cost must be defined using autograd.
Currently this is correct but not efficient, because of the jacobian-
vector product. Hopefully this can be fixed in future.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Pymanopt dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Jamie Townsend, Niklas Koep, Sebastian Weichwald.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>