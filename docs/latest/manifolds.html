<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manifolds &mdash; Pymanopt latest documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" type="text/css" />
      <link rel="stylesheet" href="_static/katex-math.css" type="text/css" />
    <link rel="canonical" href="pymanopt.org/manifolds.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"></script>
        <script src="_static/katex_autorenderer.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Autodiff" href="autodiff.html" />
    <link rel="prev" title="API Reference" href="api-reference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Pymanopt
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pymanopt/pymanopt/tree/master/examples">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api-reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Manifolds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.manifold">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Euclidean Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.sphere">Sphere Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">Stiefel Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">Grassmann Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.complex_circle">Complex Circle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.special_orthogonal_group">Special Orthogonal Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.oblique">Oblique Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.psd">Manifold of Positive Semidefinite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.fixed_rank">Fixed-Rank Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.strictly_positive_vectors">Strictly-Positive Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.product">Product Manifold</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="autodiff.html">Autodiff</a></li>
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples/notebooks/mixture_of_gaussians.html">Riemannian Optimization for Inference in MoG models</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pymanopt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="api-reference.html">API Reference</a> &raquo;</li>
      <li>Manifolds</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/manifolds.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="manifolds">
<h1>Manifolds<a class="headerlink" href="#manifolds" title="Permalink to this headline"></a></h1>
<p>The rigorous mathematical definition of a manifold is beyond the scope of this
document.
However, if you are unfamiliar with the idea, it is fine just to visualize it
as a smooth subset of <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_space">Euclidean space</a>.
Simple examples include the surface of a sphere or a <a class="reference external" href="https://en.wikipedia.org/wiki/Torus">torus</a>, or the <a class="reference external" href="https://en.wikipedia.org/wiki/Möbius_strip">Möbius strip</a>.
For an exact definition and a general background on Riemannian optimization we
refer readers to the monographs <a class="reference internal" href="bibliography.html#ams2008" id="id1"><span>[AMS2008]</span></a> and <a class="reference internal" href="bibliography.html#bou2020" id="id2"><span>[Bou2020]</span></a> (both of which are
freely available online).
If you need to solve an optimization problem with a search space that is
constrained in some smooth way, then performing optimization on manifolds may
well be the natural approach to take.</p>
<p>The manifolds that we currently support are listed below.
We plan to implement more depending on the needs of users, so if there is a
particular manifold you would like to optimize over, please let us know.
If you wish to implement your own manifold for Pymanopt, you will
need to inherit from the abstract <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>
or <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a> base
class.</p>
<div class="section" id="module-pymanopt.manifolds.manifold">
<span id="manifold"></span><h2>Manifold<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Riemannian manifold base class.</p>
<p>Abstract base class setting out a template for manifold classes.</p>
<p>Not all methods are required by all solvers.
In particular, first order gradient based solvers such as
<a class="reference internal" href="solvers.html#module-pymanopt.solvers.steepest_descent" title="pymanopt.solvers.steepest_descent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.steepest_descent</span></code></a> and
<a class="reference internal" href="solvers.html#module-pymanopt.solvers.conjugate_gradient" title="pymanopt.solvers.conjugate_gradient"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.conjugate_gradient</span></code></a> require <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="pymanopt.manifolds.manifold.Manifold.egrad2rgrad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">egrad2rgrad()</span></code></a> to
be implemented but not <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.
Second order solvers such as <a class="reference internal" href="solvers.html#module-pymanopt.solvers.trust_regions" title="pymanopt.solvers.trust_regions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.trust_regions</span></code></a> will
require <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays. In this case,
<cite>point_layout</cite> describes how many elements such tuples/lists contain.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.inner">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.proj">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.norm">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.rand">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.randvec">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.zerovec">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.exp" title="pymanopt.manifolds.manifold.Manifold.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">EuclideanEmbeddedSubmanifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Embedded submanifolds of Euclidean space.</p>
<p>This class provides a generic way to project Euclidean gradients to their
Riemannian counterparts via the <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">egrad2rgrad()</span></code></a> method.
Similarly, if the Weingarten map (also known as shape operator) is provided
via implementing the <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weingarten()</span></code></a> method, the class provides a
generic implementation of the <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a> method required by
second-order solvers to translate Euclidean Hessian-vector products to
their Riemannian counterparts.</p>
<p class="rubric">Notes</p>
<p>Refer to <a class="reference internal" href="bibliography.html#amt2013" id="id3"><span>[AMT2013]</span></a> for the exact definition of the Weingarten map.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.weingarten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">U</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> and a
vector <code class="docutils literal notranslate"><span class="pre">V</span></code> in the normal space at <code class="docutils literal notranslate"><span class="pre">X</span></code> to produce another tangent
vector.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id4">
<h2>Euclidean Space<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2>
<span class="target" id="module-pymanopt.manifolds.euclidean"></span><dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Euclidean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Euclidean manifold.</p>
<p>Euclidean manifold of shape <code class="docutils literal notranslate"><span class="pre">(n1,</span> <span class="pre">n2,</span> <span class="pre">...,</span> <span class="pre">nk)</span></code> arrays.
Useful for unconstrained optimization problems or for unconstrained
hyperparameters as part of a product manifold.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Manifold of symmetric matrices.</p>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> symmetric matrices as a Riemannian submanifold of
Euclidean space.
If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> then this is the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> symmetric <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrices represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">SkewSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>The Euclidean space of n-by-n skew-symmetric matrices.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.sphere">
<span id="sphere-manifold"></span><h2>Sphere Manifold<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">Sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._Sphere</span></code></p>
<p>The sphere manifold.</p>
<p>Manifold of shape <span class="math">\(n_1 \times n_2 \times \ldots \times n_k\)</span> tensors
with unit 2-norm.
The metric is such that the sphere is a Riemannian submanifold of Euclidean
space.</p>
<p class="rubric">Notes</p>
<p>The implementation of the Weingarten map is taken from <a class="reference internal" href="bibliography.html#amt2013" id="id5"><span>[AMT2013]</span></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace intersection manifold.</p>
<p>Manifold of n-dimensional unit 2-norm vectors intersecting the
<span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span> spanned by the columns of
the matrix <code class="docutils literal notranslate"><span class="pre">U</span></code> of size <span class="math">\(n \times r\)</span>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceComplementIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceComplementIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace compliment intersection manifold.</p>
<p>Manifold of n-dimensional unit 2-norm vectors which are orthogonal to
the <span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span> spanned by columns of
the matrix <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.stiefel">
<span id="stiefel-manifold"></span><h2>Stiefel Manifold<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.stiefel.</span></span><span class="sig-name descname"><span class="pre">Stiefel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>The Stiefel manifold.</p>
<p>The optional argument k allows the user to optimize over the product of k
Stiefels.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.grassmann">
<span id="grassmann-manifold"></span><h2>Grassmann Manifold<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">Grassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>The Grassmannian.</p>
<p>This is the manifold of p-dimensional subspaces of n dimensional real
vector space.
The optional argument k allows the user to optimize over the product of k
Grassmannians.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="pymanopt.manifolds.grassmann.Grassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pymanopt.manifolds.complex_grassmann"></span><dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.complex_grassmann.</span></span><span class="sig-name descname"><span class="pre">ComplexGrassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>The complex Grassmannian.</p>
<p>This is the manifold of p-dimensional subspaces of n dimensional complex
vector space.
The optional argument k allows the user to optimize over the product of k
Grassmannians.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.exp" title="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_grassmann.ComplexGrassmann.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_grassmann.html#ComplexGrassmann.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_grassmann.ComplexGrassmann.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.complex_circle">
<span id="complex-circle"></span><h2>Complex Circle<a class="headerlink" href="#module-pymanopt.manifolds.complex_circle" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.complex_circle.</span></span><span class="sig-name descname"><span class="pre">ComplexCircle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of unit-modulus complex numbers.</p>
<p>Description of vectors z in C^n (complex) such that each component z(i)
has unit modulus. The manifold structure is the Riemannian submanifold
structure from the embedding space R^2 x … x R^2, i.e., the complex
circle is identified with the unit circle in the real plane.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.tangent">
<span class="sig-name descname"><span class="pre">tangent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.tangent" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zdot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="pymanopt.manifolds.complex_circle.ComplexCircle.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">z1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.special_orthogonal_group">
<span id="special-orthogonal-group"></span><h2>Special Orthogonal Group<a class="headerlink" href="#module-pymanopt.manifolds.special_orthogonal_group" title="Permalink to this headline"></a></h2>
<p>Module containing manifolds of n-dimensional rotations.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.special_orthogonal_group.</span></span><span class="sig-name descname"><span class="pre">SpecialOrthogonalGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>The special orthogonal group.</p>
<p>Special orthogonal group (the manifold of rotations): deals with matrices
X of size k x n x n (or n x n if k = 1, which is the default) such that
each n x n matrix is orthogonal, with determinant 1, i.e.,
dot(X.T, X) = eye(n) if k = 1, or dot(X[i].T, X[i]) = eye(n) if k &gt; 1.</p>
<p>This is a description of SO(n)^k with the induced metric from the
embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
submanifold of (R^nxn)^k endowed with the usual trace inner product.</p>
<p>Tangent vectors are represented in the Lie algebra, i.e., as skew
symmetric matrices. Use the function manifold.tangent2ambient(X, H) to
switch from the Lie algebra representation to the embedding space
representation. This is often necessary when defining
problem.ehess(X, H).</p>
<p>By default, the retraction is only a first-order approximation of the
exponential. To force the use of a second-order approximation, call
manifold.retr = manifold.retr2 after creating M. This switches from a
QR-based computation to an SVD-based computation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.tangent">
<span class="sig-name descname"><span class="pre">tangent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.tangent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.tangent" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.tangent2ambient">
<span class="sig-name descname"><span class="pre">tangent2ambient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.tangent2ambient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.tangent2ambient" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retr2">
<span class="sig-name descname"><span class="pre">retr2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.retr2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retr2" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.oblique">
<span id="oblique-manifold"></span><h2>Oblique Manifold<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.oblique.</span></span><span class="sig-name descname"><span class="pre">Oblique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of matrices w/ unit-norm columns.</p>
<p>Oblique manifold: deals with matrices of size m-by-n such that each column
has unit 2-norm, i.e., is a point on the unit sphere in R^m. The metric
is such that the oblique manifold is a Riemannian submanifold of the
space of m-by-n matrices with the usual trace inner product, i.e., the
usual metric.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>numpy.ndarray</em>) – The base point.</p></li>
<li><p><strong>U</strong> (<em>numpy.ndarray</em>) – The first tangent vector.</p></li>
<li><p><strong>V</strong> (<em>numpy.ndarray</em>) – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.float64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique.exp" title="pymanopt.manifolds.oblique.Oblique.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.psd">
<span id="manifold-of-positive-semidefinite-matrices"></span><h2>Manifold of Positive Semidefinite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">SymmetricPositiveDefinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of symmetric positive definite matrices.</p>
<p class="rubric">Notes</p>
<p>The geometry is based on the discussion in chapter 6 of <a class="reference internal" href="bibliography.html#bha2007" id="id6"><span>[Bha2007]</span></a>.
Also see <a class="reference internal" href="bibliography.html#sh2015" id="id7"><span>[SH2015]</span></a> for more details.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp" title="pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank positive semidefinite (PSD) matrices.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may
be big). Tangent vectors are represented as matrices of the same size as
Y, call them Ydot, so that Xdot = Y Ydot’ + Ydot Y. The metric is the
canonical Euclidean metric on Y.</p>
<p>Since for any orthogonal Q of size k, it holds that (YQ)(YQ)’ = YY’,
we “group” all matrices of the form YQ in an equivalence class. The set
of equivalence classes is a Riemannian quotient manifold, implemented
here.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<p>An alternative, complete, geometry for positive semidefinite matrices of
rank k is described in Bonnabel and Sepulchre 2009, “Riemannian Metric
and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank”,
SIAM Journal on Matrix Analysis and Applications.</p>
<p>The geometry implemented here is the simplest case of the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRankComplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank Hermitian positive semidefinite (PSD) matrices.</p>
<p>Manifold of n-by-n complex Hermitian positive semidefinite matrices of
fixed rank k. This follows the quotient geometry described
in Sarod Yatawatta’s 2013 paper:
“Radio interferometric calibration using a Riemannian manifold”, ICASSP.</p>
<p>Paper link: <a class="reference external" href="http://dx.doi.org/10.1109/ICASSP.2013.6638382">http://dx.doi.org/10.1109/ICASSP.2013.6638382</a>.</p>
<p>A point X on the manifold M is parameterized as YY^*, where Y is a
complex matrix of size nxk of full rank. For any point Y on the manifold M,
given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y,
i.e., YY^* does not change. Therefore, M is the set of equivalence
classes and is a Riemannian quotient manifold C^{nk}/U(k)
where C^{nk} is the set of all complex matrix of size nxk of full rank.
The metric is the usual real-trace inner product, that is,
it is the usual metric for the complex plane identified with R^2.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">Elliptope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._RetrAsExpMixin</span></code></p>
<p>Manifold of fixed-rank PSD matrices with unit diagonal elements.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may be
big). Tangent vectors are represented as matrices of the same size as Y,
call them Ydot, so that Xdot = Y Ydot’ + Ydot Y and diag(Xdot) == 0. The
metric is the canonical Euclidean metric on Y.</p>
<p>The diagonal constraints on X (X(i, i) == 1 for all i) translate to
unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.  The
set of such Y’s forms the oblique manifold. But because for any orthogonal
Q of size k, it holds that (YQ)(YQ)’ = YY’, we “group” all matrices of the
form YQ in an equivalence class. The set of equivalence classes is a
Riemannian quotient manifold, implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient Y’s.  This
does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient Y’s, but convergence theorems no
longer hold. As an alternative, you may use the oblique manifold (it has
larger dimension, but does not break down at rank drop.)</p>
<p>The geometry is taken from the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.fixed_rank">
<span id="fixed-rank-matrices"></span><h2>Fixed-Rank Matrices<a class="headerlink" href="#module-pymanopt.manifolds.fixed_rank" title="Permalink to this headline"></a></h2>
<p>Module containing manifolds of fixed-rank matrices.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.fixed_rank.</span></span><span class="sig-name descname"><span class="pre">FixedRankEmbedded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of fixed rank matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows of the matrices in the ambient space.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns of the matrices.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The rank of the matrices on the manifold.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The implementation follows the embedded geometry described in
<a class="reference internal" href="bibliography.html#van2013" id="id8"><span>[Van2013]</span></a>.</p></li>
<li><p>The class is currently not compatible with the
<code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.TrustRegions</span></code> solver.</p></li>
</ul>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> real matrices of fixed rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.
For efficiency purposes, Pymanopt does not represent points on this
manifold explicitly using <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices, but instead implicitly using
a truncated singular value decomposition.
Specifically, a point is represented by a tuple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">s,</span> <span class="pre">vt)</span></code> of three
numpy arrays.
The arrays <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">vt</span></code> have shapes <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">k)</span></code>, <code class="docutils literal notranslate"><span class="pre">(k,)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n)</span></code>, respectively, and the low rank matrix which they represent can
be recovered by the matrix product <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">*</span> <span class="pre">diag(s)</span> <span class="pre">*</span> <span class="pre">vt</span></code>.</p>
<p>For example, to optimize over the space of 5 x 4 matrices with rank 3, we</p>
<p>would need to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pymanopt.manifolds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manifold</span> <span class="o">=</span> <span class="n">pymanopt</span><span class="o">.</span><span class="n">manifolds</span><span class="o">.</span><span class="n">FixedRankEmbedded</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the shapes will be as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vt</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4)</span>
</pre></div>
</div>
<p>and the full matrix can be recovered using the matrix product
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vt</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">u</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">@</span> <span class="n">vt</span>
</pre></div>
</div>
<p>Tangent vectors are represented as a tuple <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code>.
The matrices <code class="docutils literal notranslate"><span class="pre">Up</span></code> (of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">k</span></code>) and <code class="docutils literal notranslate"><span class="pre">Vp</span></code> (of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">k</span></code>) obey
<code class="docutils literal notranslate"><span class="pre">Up'</span> <span class="pre">*</span> <span class="pre">U</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">and</span> <span class="pre">Vp'</span> <span class="pre">*</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">0</span></code>.
The matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> (of size <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">k</span></code>) is arbitrary.
Such a structure corresponds to the
following tangent vector in the ambient space of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices: <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span>
<span class="pre">U</span> <span class="pre">*</span> <span class="pre">M</span> <span class="pre">*</span> <span class="pre">V'</span> <span class="pre">+</span> <span class="pre">Up</span> <span class="pre">*</span> <span class="pre">V'</span> <span class="pre">+</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">Vp'</span></code>
where <code class="docutils literal notranslate"><span class="pre">(U,</span> <span class="pre">S,</span> <span class="pre">V)</span></code> is the current point and <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code> is the tangent
vector at that point.</p>
<p>Vectors in the ambient space are best represented as <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices.
If these are low-rank, they may also be represented as structures with
<code class="docutils literal notranslate"><span class="pre">U,</span> <span class="pre">S,</span> <span class="pre">V</span></code> fields, such that <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>.
There are no restrictions on what <code class="docutils literal notranslate"><span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> are, as long as
their product as indicated yields a real <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix.</p>
<p>The chosen geometry yields a Riemannian submanifold of the embedding
space <span class="math">\(\R^(m \times n)\)</span> equipped with the usual trace (Frobenius)
inner product.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.proj" title="Permalink to this definition"></a></dt>
<dd><p>Project point to tangent space.</p>
<p>Note that Z must either be an m x n matrix from the ambient space, or
else a tuple (Uz, Sz, Vz), where Uz * Sz * Vz is in the ambient space
(of low-rank matrices).</p>
<p>This function then returns a tangent vector parameterized as
(Up, M, Vp), as described in the class docstring.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Convert Euclidean to Riemannian gradient.</p>
<p>Assuming that the cost function being optimized has been defined
in terms of the low-rank singular value decomposition of X, the
gradient returned by the autodiff backends will have three components
and will be in the form of a tuple egrad = (df/dU, df/dS, df/dV).</p>
<p>This function correctly maps a gradient of this form into the tangent
space. See <a class="reference external" href="https://j-towns.github.io/papers/svd-derivative.pdf">https://j-towns.github.io/papers/svd-derivative.pdf</a> for a
derivation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.tangent2ambient">
<span class="sig-name descname"><span class="pre">tangent2ambient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.tangent2ambient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.tangent2ambient" title="Permalink to this definition"></a></dt>
<dd><p>Represent tangent vector in ambient space.</p>
<p>Transforms a tangent vector Z represented as a structure (Up, M, Vp)
into a structure with fields (U, S, V) that represents that same
tangent vector in the ambient space of mxn matrices, as U*S*V’.
This matrix is equal to X.U*Z.M*X.V’ + Z.Up*X.V’ + X.U*Z.Vp’.
The latter is an mxn matrix, which could be too large to build
explicitly, and this is why we return a low-rank representation
instead.
Note that there are no guarantees on U, S and V other than that USV’ is
the desired matrix.
In particular, U and V are not (in general) orthonormal and S is not
(in general) diagonal.
Currently, S is identity, but this might change.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.strictly_positive_vectors">
<span id="strictly-positive-vectors"></span><h2>Strictly-Positive Vectors<a class="headerlink" href="#module-pymanopt.manifolds.strictly_positive_vectors" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.strictly_positive_vectors.</span></span><span class="sig-name descname"><span class="pre">StrictlyPositiveVectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of strictly positive vectors.</p>
<p>Since <span class="math">\(((\R_{++})^n)^k\)</span> is isomorphic to the manifold of positive
definite diagonal matrices the geometry is inherited from the geometry of
positive definite matrices.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/strictly_positive_vectors.html#StrictlyPositiveVectors.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.exp" title="pymanopt.manifolds.strictly_positive_vectors.StrictlyPositiveVectors.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.product">
<span id="product-manifold"></span><h2>Product Manifold<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.product.</span></span><span class="sig-name descname"><span class="pre">Product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifolds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Product manifold, i.e., the cartesian product of multiple manifolds.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.product.Product.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions solver to determine default initial
and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.inner" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>The inner product corresponds to the Riemannian metric between two
tangent vectors <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">H</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds, this is simply the projection of <code class="docutils literal notranslate"><span class="pre">G</span></code> on
the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian <code class="docutils literal notranslate"><span class="pre">H</span></code> of a function at a point
<code class="docutils literal notranslate"><span class="pre">X</span></code> along a tangent vector <code class="docutils literal notranslate"><span class="pre">U</span></code> to the Riemannian Hessian of <code class="docutils literal notranslate"><span class="pre">X</span></code>
along <code class="docutils literal notranslate"><span class="pre">U</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.retr" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code> back to the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>This is the inverse of <a class="reference internal" href="#pymanopt.manifolds.product.Product.exp" title="pymanopt.manifolds.product.Product.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.transp" title="Permalink to this definition"></a></dt>
<dd><p>Transport a tangent vector between different tangent spaces.</p>
<p>The vector transport generalizes the concept of parallel transport, and
is often more efficient to compute numerically.
It transports a vector <code class="docutils literal notranslate"><span class="pre">G</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">X1</span></code> to the
tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api-reference.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="autodiff.html" class="btn btn-neutral float-right" title="Autodiff" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Jamie Townsend, Niklas Koep, Sebastian Weichwald.
      <span class="lastupdated">Last updated on Dec 31, 2021.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: latest
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/docs/latest">latest</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>