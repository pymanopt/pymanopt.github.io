

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; Pymanopt dev documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Pymanopt" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Pymanopt
          

          
          </a>

          
            
            
              <div class="version">
                dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.core.problem">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="#manifolds">Manifolds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.manifold">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.euclidean">Euclidean Space as a Riemannian Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">The Grassmann Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.oblique">The Oblique Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.product">The Product Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.psd">The Manifolds of Positive Semidefinite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.sphere">The Hypersphere Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">The Stiefel Manifold</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solvers">Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.solver">Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.conjugate_gradient">Riemannian Conjugate Gradients</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.nelder_mead">The Nelder-Mead Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.particle_swarm">Particle Swarms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.steepest_descent">The Riemannian Steepest Descent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.trust_regions">Second-Order Riemannian Trust Regions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.solvers.linesearch">Line-Search Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.tools.autodiff">Autodiff Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.tools.multi">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.tools.testing">Testing</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pymanopt</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api-reference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pymanopt.core.problem">
<span id="problem"></span><h2>Problem<a class="headerlink" href="#module-pymanopt.core.problem" title="Permalink to this headline">¶</a></h2>
<p>Module containing pymanopt problem class. Use this to build a problem
object to feed to one of the solvers.</p>
<dl class="class">
<dt id="pymanopt.core.problem.Problem">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.core.problem.</code><code class="sig-name descname">Problem</code><span class="sig-paren">(</span><em class="sig-param">manifold</em>, <em class="sig-param">cost</em>, <em class="sig-param">egrad=None</em>, <em class="sig-param">ehess=None</em>, <em class="sig-param">grad=None</em>, <em class="sig-param">hess=None</em>, <em class="sig-param">arg=None</em>, <em class="sig-param">precon=None</em>, <em class="sig-param">verbosity=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/core/problem.html#Problem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.core.problem.Problem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Problem class for setting up a problem to feed to one of the
pymanopt solvers.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>manifold</dt><dd><p>Manifold to optimize over.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cost</dt><dd><p>A callable which takes an element of manifold and returns a
real number, or a symbolic Theano or TensorFlow expression.
In case of a symbolic expression, the gradient (and if
necessary the Hessian) are computed automatically if they are
not explicitly given. We recommend you take this approach
rather than calculating gradients and Hessians by hand.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>grad</dt><dd><p>grad(x) is the gradient of cost at x. This must take an
element X of manifold and return an element of the tangent space
to manifold at X. This is usually computed automatically and
doesn’t need to be set by the user.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>hess</dt><dd><p>hess(x, a) is the directional derivative of grad at x, in
direction a. It should return an element of the tangent
space to manifold at x.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>egrad</dt><dd><p>The ‘Euclidean gradient’, egrad(x) should return the grad of
cost in the usual sense, i.e. egrad(x) need not lie in the
tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ehess</dt><dd><p>The ‘Euclidean Hessian’, ehess(x, a) should return the
directional derivative of egrad at x in direction a. This
need not lie in the tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>arg</dt><dd><p>A symbolic (tensor) variable with respect to which you would like
to optimize. Its type (together with the type of the cost argument)
defines the autodiff backend used.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>verbosity (2)</dt><dd><p>Level of information printed by the solver while it operates, 0
is silent, 2 is most information.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pymanopt.core.problem.Problem.backend">
<em class="property">property </em><code class="sig-name descname">backend</code><a class="headerlink" href="#pymanopt.core.problem.Problem.backend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.core.problem.Problem.cost">
<em class="property">property </em><code class="sig-name descname">cost</code><a class="headerlink" href="#pymanopt.core.problem.Problem.cost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.core.problem.Problem.egrad">
<em class="property">property </em><code class="sig-name descname">egrad</code><a class="headerlink" href="#pymanopt.core.problem.Problem.egrad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.core.problem.Problem.ehess">
<em class="property">property </em><code class="sig-name descname">ehess</code><a class="headerlink" href="#pymanopt.core.problem.Problem.ehess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.core.problem.Problem.grad">
<em class="property">property </em><code class="sig-name descname">grad</code><a class="headerlink" href="#pymanopt.core.problem.Problem.grad" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.core.problem.Problem.hess">
<em class="property">property </em><code class="sig-name descname">hess</code><a class="headerlink" href="#pymanopt.core.problem.Problem.hess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="manifolds">
<h2>Manifolds<a class="headerlink" href="#manifolds" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.manifolds.manifold">
<span id="manifold"></span><h3>Manifold<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.manifold.Manifold">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.manifold.</code><code class="sig-name descname">Manifold</code><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class setting out a template for manifold classes. If you
would like to extend Pymanopt with a new manifold, then your manifold
should inherit from this class.</p>
<p>Not all methods are required by all solvers. In particular, first order
gradient based solvers such as
<a class="reference internal" href="#module-pymanopt.solvers.steepest_descent" title="pymanopt.solvers.steepest_descent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.steepest_descent</span></code></a> and
<a class="reference internal" href="#module-pymanopt.solvers.conjugate_gradient" title="pymanopt.solvers.conjugate_gradient"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.conjugate_gradient</span></code></a> require
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="pymanopt.manifolds.manifold.Manifold.egrad2rgrad"><code class="xref py py-func docutils literal notranslate"><span class="pre">egrad2rgrad()</span></code></a> to be implemented but not <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-func docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.
Second order solvers such as <a class="reference internal" href="#module-pymanopt.solvers.trust_regions" title="pymanopt.solvers.trust_regions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.trust_regions</span></code></a>
will require <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-func docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.</p>
<p>All of these methods correspond closely to methods in
<a class="reference external" href="http://www.manopt.org">Manopt</a>. See
<a class="reference external" href="http://www.manopt.org/tutorial.html#manifolds">http://www.manopt.org/tutorial.html#manifolds</a> for more details on manifolds
in Manopt, which are effectively identical to those in Pymanopt (all of the
methods in this class have equivalents in Manopt with the same name).</p>
<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.dim">
<em class="property">abstract property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.dist">
<em class="property">abstract </em><code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.ehess2rhess">
<em class="property">abstract </em><code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Hess</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.exp">
<em class="property">abstract </em><code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.inner">
<em class="property">abstract </em><code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.log">
<em class="property">abstract </em><code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.norm">
<em class="property">abstract </em><code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.pairmean">
<em class="property">abstract </em><code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.proj">
<em class="property">abstract </em><code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.rand">
<em class="property">abstract </em><code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.randvec">
<em class="property">abstract </em><code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.retr">
<em class="property">abstract </em><code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.transp">
<em class="property">abstract </em><code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.typicaldist">
<em class="property">abstract property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.manifold.Manifold.zerovec">
<code class="sig-name descname">zerovec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.zerovec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zerovec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero tangent vector at X.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.euclidean">
<span id="euclidean-space-as-a-riemannian-manifold"></span><h3>Euclidean Space as a Riemannian Manifold<a class="headerlink" href="#module-pymanopt.manifolds.euclidean" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.euclidean.</code><code class="sig-name descname">Euclidean</code><span class="sig-paren">(</span><em class="sig-param">*shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Euclidean manifold of shape n1 x n2 x … x nk tensors. Useful for
unconstrained optimization problems or for unconstrained hyperparameters,
as part of a product manifold.</p>
<p>Examples:
Create a manifold of vectors of length n:
manifold = Euclidean(n)</p>
<p>Create a manifold of m x n matrices:
manifold = Euclidean(m, n)</p>
<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">X1</em>, <em class="sig-param">X2</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Euclidean.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.euclidean.</code><code class="sig-name descname">SkewSymmetric</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.euclidean.Euclidean" title="pymanopt.manifolds.euclidean.Euclidean"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean.Euclidean</span></code></a></p>
<p>The Euclidean space of n-by-n skew-symmetric matrices.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.SkewSymmetric.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.euclidean.Symmetric">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.euclidean.</code><code class="sig-name descname">Symmetric</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.euclidean.Euclidean" title="pymanopt.manifolds.euclidean.Euclidean"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean.Euclidean</span></code></a></p>
<p>Manifold of n x n symmetric matrices, as a Riemannian submanifold of
Euclidean space.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.euclidean.Symmetric.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.grassmann">
<span id="the-grassmann-manifold"></span><h3>The Grassmann Manifold<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.grassmann.</code><code class="sig-name descname">Grassmann</code><span class="sig-paren">(</span><em class="sig-param">height</em>, <em class="sig-param">width</em>, <em class="sig-param">k=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Factory class for the Grassmann manifold. This is the manifold of p-
dimensional subspaces of n dimensional real vector space. Initiation
requires the dimensions n, p to be specified. Optional argument k
allows the user to optimize over the product of k Grassmanns.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.grassmann.Grassmann.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.oblique">
<span id="the-oblique-manifold"></span><h3>The Oblique Manifold<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.oblique.Oblique">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.oblique.</code><code class="sig-name descname">Oblique</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of matrices w/ unit-norm columns.</p>
<p>Oblique manifold: deals with matrices of size m-by-n such that each column
has unit 2-norm, i.e., is a point on the unit sphere in R^m. The metric
is such that the oblique manifold is a Riemannian submanifold of the
space of m-by-n matrices with the usual trace inner product, i.e., the
usual metric.</p>
<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.oblique.Oblique.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.product">
<span id="the-product-manifold"></span><h3>The Product Manifold<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.product.Product">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.product.</code><code class="sig-name descname">Product</code><span class="sig-paren">(</span><em class="sig-param">manifolds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Product manifold, i.e. the cartesian product of multiple manifolds.</p>
<dl class="method">
<dt id="pymanopt.manifolds.product.Product.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.product.Product.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">X1</em>, <em class="sig-param">X2</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.product.Product.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.product.Product.zerovec">
<code class="sig-name descname">zerovec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.zerovec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.zerovec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero tangent vector at X.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.psd">
<span id="the-manifolds-of-positive-semidefinite-matrices"></span><h3>The Manifolds of Positive Semidefinite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.psd.Elliptope">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.psd.</code><code class="sig-name descname">Elliptope</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of n-by-n psd matrices of rank k with unit diagonal elements.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may be
big). Tangent vectors are represented as matrices of the same size as Y,
call them Ydot, so that Xdot = Y Ydot’ + Ydot Y and diag(Xdot) == 0. The
metric is the canonical Euclidean metric on Y.</p>
<p>The diagonal constraints on X (X(i, i) == 1 for all i) translate to
unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.  The
set of such Y’s forms the oblique manifold. But because for any orthogonal
Q of size k, it holds that (YQ)(YQ)’ = YY’, we “group” all matrices of the
form YQ in an equivalence class. The set of equivalence classes is a
Riemannian quotient manifold, implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient Y’s.  This
does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient Y’s, but convergence theorems no
longer hold. As an alternative, you may use the oblique manifold (it has
larger dimension, but does not break down at rank drop.)</p>
<p>The geometry is taken from the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">egrad</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">Z</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.Elliptope.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.psd.</code><code class="sig-name descname">PSDFixedRank</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of n-by-n symmetric positive semidefinite matrices of rank k.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may
be big). Tangent vectors are represented as matrices of the same size as
Y, call them Ydot, so that Xdot = Y Ydot’ + Ydot Y. The metric is the
canonical Euclidean metric on Y.</p>
<p>Since for any orthogonal Q of size k, it holds that (YQ)(YQ)’ = YY’,
we “group” all matrices of the form YQ in an equivalence class. The set
of equivalence classes is a Riemannian quotient manifold, implemented
here.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<p>An alternative, complete, geometry for positive semidefinite matrices of
rank k is described in Bonnabel and Sepulchre 2009, “Riemannian Metric
and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank”,
SIAM Journal on Matrix Analysis and Applications.</p>
<p>The geometry implemented here is the simplest case of the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">egrad</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">Z</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRank.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.psd.</code><code class="sig-name descname">PSDFixedRankComplex</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.psd.PSDFixedRank" title="pymanopt.manifolds.psd.PSDFixedRank"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd.PSDFixedRank</span></code></a></p>
<p>Manifold of n x n complex Hermitian pos. semidefinite matrices of rank k.</p>
<p>Manifold of n-by-n complex Hermitian positive semidefinite matrices of
fixed rank k. This follows the quotient geometry described
in Sarod Yatawatta’s 2013 paper:
“Radio interferometric calibration using a Riemannian manifold”, ICASSP.</p>
<p>Paper link: <a class="reference external" href="http://dx.doi.org/10.1109/ICASSP.2013.6638382">http://dx.doi.org/10.1109/ICASSP.2013.6638382</a>.</p>
<p>A point X on the manifold M is parameterized as YY^*, where Y is a
complex matrix of size nxk of full rank. For any point Y on the manifold M,
given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y,
i.e., YY^* does not change. Therefore, M is the set of equivalence
classes and is a Riemannian quotient manifold C^{nk}/U(k)
where C^{nk} is the set of all complex matrix of size nxk of full rank.
The metric is the usual real-trace inner product, that is,
it is the usual metric for the complex plane identified with R^2.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PSDFixedRankComplex.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.psd.PositiveDefinite">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.psd.</code><code class="sig-name descname">PositiveDefinite</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">k=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of (n x n)^k positive definite matrices, based on the geometry
discussed in Chapter 6 of Positive Definite Matrices (Bhatia 2007). Some
of the implementation is based on sympositivedefinitefactory.m from the
Manopt MATLAB package. Also see “Conic geometric optimisation on the
manifold of positive definite matrices” (Sra &amp; Hosseini 2013) for more
details.</p>
<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.egrad2rgrad">
<code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping from the Euclidean gradient G into the tangent space
to the manifold at X. For embedded manifolds, this is simply the
projection of G on the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">u</em>, <em class="sig-param">v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PositiveDefinite.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.psd.PositiveDefinite.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.psd.PositiveDefinite.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.sphere">
<span id="the-hypersphere-manifold"></span><h3>The Hypersphere Manifold<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.sphere.Sphere">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.sphere.</code><code class="sig-name descname">Sphere</code><span class="sig-paren">(</span><em class="sig-param">*shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Manifold of shape n1 x n2 x … x nk tensors with unit 2-norm. The
metric is such that the sphere is a Riemannian submanifold of Euclidean
space. This implementation is based on spherefactory.m from the Manopt
MATLAB package.</p>
<p>Examples:
The ‘usual’ sphere S^2, the set of points lying on the surface of a ball in
3D space:
sphere = Sphere(3)</p>
<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em>, <em class="sig-param">V</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.Sphere.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.sphere.</code><code class="sig-name descname">SphereSubspaceComplementIntersection</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">U=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceComplementIntersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="pymanopt.manifolds.sphere.SphereSubspaceIntersection"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere.SphereSubspaceIntersection</span></code></a></p>
<p>Manifold of n-dimensional unit 2-norm vectors which are orthogonal to the
r-dimensional subspace of R^n spanned by columns of the matrix U. This
implementation is based on spheresubspacefactory.m from the Manopt MATLAB
package.</p>
</dd></dl>

<dl class="class">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceIntersection">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.sphere.</code><code class="sig-name descname">SphereSubspaceIntersection</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">U=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.sphere.Sphere" title="pymanopt.manifolds.sphere.Sphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere.Sphere</span></code></a></p>
<p>Manifold of n-dimensional unit 2-norm vectors intersecting the
r-dimensional subspace of R^n spanned by the columns of the matrix U. This
implementation is based on spheresubspacefactory.m from the Manopt MATLAB
package.</p>
<dl class="method">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.sphere.SphereSubspaceIntersection.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.stiefel">
<span id="the-stiefel-manifold"></span><h3>The Stiefel Manifold<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.manifolds.stiefel.</code><code class="sig-name descname">Stiefel</code><span class="sig-paren">(</span><em class="sig-param">height</em>, <em class="sig-param">width</em>, <em class="sig-param">k=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Factory class for the Stiefel manifold. Initiation requires the dimensions
n, p to be specified. Optional argument k allows the user to optimize over
the product of k Stiefels.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.dim">
<em class="property">property </em><code class="sig-name descname">dim</code><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.dist">
<code class="sig-name descname">dist</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Geodesic distance on the manifold</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.ehess2rhess">
<code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">egrad</em>, <em class="sig-param">ehess</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Euclidean into Riemannian Hessian.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential (in the sense of Lie group theory) of a tangent
vector U at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em>, <em class="sig-param">H</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product (Riemannian metric) on the tangent space</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.log" title="Permalink to this definition">¶</a></dt>
<dd><p>The logarithm (in the sense of Lie group theory) of Y. This is the
inverse of exp.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of a tangent vector G, which is tangent to the
manifold at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.pairmean">
<code class="sig-name descname">pairmean</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.pairmean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.pairmean" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the intrinsic mean of X and Y, that is, a point that lies
mid-way between X and Y on the geodesic arc joining them.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.proj">
<code class="sig-name descname">proj</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">U</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Project into the tangent space. Usually the same as egrad2rgrad</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.rand">
<code class="sig-name descname">rand</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.rand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>A function which returns a random point on the manifold.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.randvec">
<code class="sig-name descname">randvec</code><span class="sig-paren">(</span><em class="sig-param">X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.randvec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.randvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random, unit norm vector in the tangent space at X.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.retr">
<code class="sig-name descname">retr</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">G</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.retr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.retr" title="Permalink to this definition">¶</a></dt>
<dd><p>A retraction mapping from the tangent space at X to the manifold.
See Absil for definition of retraction.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.transp">
<code class="sig-name descname">transp</code><span class="sig-paren">(</span><em class="sig-param">x1</em>, <em class="sig-param">x2</em>, <em class="sig-param">d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.transp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.transp" title="Permalink to this definition">¶</a></dt>
<dd><p>Transports d, which is a tangent vector at x1, into the tangent
space at x2.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.manifolds.stiefel.Stiefel.typicaldist">
<em class="property">property </em><code class="sig-name descname">typicaldist</code><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.typicaldist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver, to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="solvers">
<h2>Solvers<a class="headerlink" href="#solvers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pymanopt.solvers.solver">
<span id="solver"></span><h3>Solver<a class="headerlink" href="#module-pymanopt.solvers.solver" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.solver.Solver">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.solver.</code><code class="sig-name descname">Solver</code><span class="sig-paren">(</span><em class="sig-param">maxtime=1000</em>, <em class="sig-param">maxiter=1000</em>, <em class="sig-param">mingradnorm=1e-06</em>, <em class="sig-param">minstepsize=1e-10</em>, <em class="sig-param">maxcostevals=5000</em>, <em class="sig-param">logverbosity=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/solver.html#Solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.solver.Solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class setting out template for solver classes.</p>
<dl class="method">
<dt id="pymanopt.solvers.solver.Solver.solve">
<em class="property">abstract </em><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/solver.html#Solver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.solver.Solver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the given <a class="reference internal" href="#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> (starting
from a random initial guess if the optional argument x is not
provided).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.conjugate_gradient">
<span id="riemannian-conjugate-gradients"></span><h3>Riemannian Conjugate Gradients<a class="headerlink" href="#module-pymanopt.solvers.conjugate_gradient" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.conjugate_gradient.ConjugateGradient">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.conjugate_gradient.</code><code class="sig-name descname">ConjugateGradient</code><span class="sig-paren">(</span><em class="sig-param">beta_type=2</em>, <em class="sig-param">orth_value=inf</em>, <em class="sig-param">linesearch=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/conjugate_gradient.html#ConjugateGradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Module containing conjugate gradient algorithm based on
conjugategradient.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em>, <em class="sig-param">reuselinesearch=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/conjugate_gradient.html#ConjugateGradient.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using nonlinear conjugate gradient method with
linesearch.
This method first computes the gradient of obj w.r.t. arg, and then
optimizes by moving in a direction that is conjugate to all previous
search directions.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>reuselinesearch=False</dt><dd><p>Whether to reuse the previous linesearch object. Allows to
use information from a previous solve run.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.nelder_mead">
<span id="the-nelder-mead-algorithm"></span><h3>The Nelder-Mead Algorithm<a class="headerlink" href="#module-pymanopt.solvers.nelder_mead" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.nelder_mead.NelderMead">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.nelder_mead.</code><code class="sig-name descname">NelderMead</code><span class="sig-paren">(</span><em class="sig-param">maxcostevals=None</em>, <em class="sig-param">maxiter=None</em>, <em class="sig-param">reflection=1</em>, <em class="sig-param">expansion=2</em>, <em class="sig-param">contraction=0.5</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#NelderMead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Nelder-Mead minimization alglorithm for derivative-free minimization
based on neldermead.m and centroid.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.nelder_mead.NelderMead.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#NelderMead.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using a Nelder-Mead minimization algorithm.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymanopt.solvers.nelder_mead.compute_centroid">
<code class="sig-prename descclassname">pymanopt.solvers.nelder_mead.</code><code class="sig-name descname">compute_centroid</code><span class="sig-paren">(</span><em class="sig-param">man</em>, <em class="sig-param">x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#compute_centroid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.compute_centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the centroid as Karcher mean of points x belonging to the manifold
man.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.particle_swarm">
<span id="particle-swarms"></span><h3>Particle Swarms<a class="headerlink" href="#module-pymanopt.solvers.particle_swarm" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.particle_swarm.ParticleSwarm">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.particle_swarm.</code><code class="sig-name descname">ParticleSwarm</code><span class="sig-paren">(</span><em class="sig-param">maxcostevals=None</em>, <em class="sig-param">maxiter=None</em>, <em class="sig-param">populationsize=None</em>, <em class="sig-param">nostalgia=1.4</em>, <em class="sig-param">social=1.4</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/particle_swarm.html#ParticleSwarm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Particle swarm optimization method based on pso.m from the manopt
MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.particle_swarm.ParticleSwarm.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/particle_swarm.html#ParticleSwarm.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using the particle swarm optimization algorithm.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost (specified using a theano graph
or as a python function).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.steepest_descent">
<span id="the-riemannian-steepest-descent"></span><h3>The Riemannian Steepest Descent<a class="headerlink" href="#module-pymanopt.solvers.steepest_descent" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.steepest_descent.SteepestDescent">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.steepest_descent.</code><code class="sig-name descname">SteepestDescent</code><span class="sig-paren">(</span><em class="sig-param">linesearch=&lt;pymanopt.solvers.linesearch.LineSearchBackTracking object&gt;</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/steepest_descent.html#SteepestDescent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Steepest descent (gradient descent) algorithm based on
steepestdescent.m from the manopt MATLAB package.</p>
<dl class="method">
<dt id="pymanopt.solvers.steepest_descent.SteepestDescent.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em>, <em class="sig-param">reuselinesearch=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/steepest_descent.html#SteepestDescent.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform optimization using gradient descent with linesearch.
This method first computes the gradient (derivative) of obj
w.r.t. arg, and then optimizes by moving in the direction of
steepest descent (which is the opposite direction to the gradient).
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>reuselinesearch=False</dt><dd><p>Whether to reuse the previous linesearch object. Allows to
use information from a previous solve run.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.solvers.trust_regions">
<span id="second-order-riemannian-trust-regions"></span><h3>Second-Order Riemannian Trust Regions<a class="headerlink" href="#module-pymanopt.solvers.trust_regions" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pymanopt.solvers.trust_regions.TrustRegions">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.trust_regions.</code><code class="sig-name descname">TrustRegions</code><span class="sig-paren">(</span><em class="sig-param">miniter=3</em>, <em class="sig-param">kappa=0.1</em>, <em class="sig-param">theta=1.0</em>, <em class="sig-param">rho_prime=0.1</em>, <em class="sig-param">use_rand=False</em>, <em class="sig-param">rho_regularization=1000.0</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/trust_regions.html#TrustRegions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR">
<code class="sig-name descname">EXCEEDED_TR</code><em class="property"> = 1</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER">
<code class="sig-name descname">MAX_INNER_ITER</code><em class="property"> = 4</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED">
<code class="sig-name descname">MODEL_INCREASED</code><em class="property"> = 5</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE">
<code class="sig-name descname">NEGATIVE_CURVATURE</code><em class="property"> = 0</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR">
<code class="sig-name descname">REACHED_TARGET_LINEAR</code><em class="property"> = 2</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR">
<code class="sig-name descname">REACHED_TARGET_SUPERLINEAR</code><em class="property"> = 3</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS">
<code class="sig-name descname">TCG_STOP_REASONS</code><em class="property"> = {0: 'negative curvature', 1: 'exceeded trust region', 2: 'reached target residual-kappa (linear)', 3: 'reached target residual-theta (superlinear)', 4: 'maximum inner iterations', 5: 'model increased'}</em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.solvers.trust_regions.TrustRegions.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">x=None</em>, <em class="sig-param">mininner=1</em>, <em class="sig-param">maxinner=None</em>, <em class="sig-param">Delta_bar=None</em>, <em class="sig-param">Delta0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/trust_regions.html#TrustRegions.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the given <a class="reference internal" href="#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> (starting
from a random initial guess if the optional argument x is not
provided).</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pymanopt.solvers.linesearch">
<span id="line-search-methods"></span><h2>Line-Search Methods<a class="headerlink" href="#module-pymanopt.solvers.linesearch" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymanopt.solvers.linesearch.LineSearchAdaptive">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.linesearch.</code><code class="sig-name descname">LineSearchAdaptive</code><span class="sig-paren">(</span><em class="sig-param">contraction_factor=0.5</em>, <em class="sig-param">suff_decr=0.5</em>, <em class="sig-param">maxiter=10</em>, <em class="sig-param">initial_stepsize=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchAdaptive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Adaptive line-search</p>
<dl class="method">
<dt id="pymanopt.solvers.linesearch.LineSearchAdaptive.search">
<code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">man</em>, <em class="sig-param">x</em>, <em class="sig-param">d</em>, <em class="sig-param">f0</em>, <em class="sig-param">df0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchAdaptive.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive.search" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.solvers.linesearch.LineSearchBackTracking">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.solvers.linesearch.</code><code class="sig-name descname">LineSearchBackTracking</code><span class="sig-paren">(</span><em class="sig-param">contraction_factor=0.5</em>, <em class="sig-param">optimism=2</em>, <em class="sig-param">suff_decr=0.0001</em>, <em class="sig-param">maxiter=25</em>, <em class="sig-param">initial_stepsize=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchBackTracking"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Back-tracking line-search based on linesearch.m in the manopt MATLAB
package.</p>
<dl class="method">
<dt id="pymanopt.solvers.linesearch.LineSearchBackTracking.search">
<code class="sig-name descname">search</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">manifold</em>, <em class="sig-param">x</em>, <em class="sig-param">d</em>, <em class="sig-param">f0</em>, <em class="sig-param">df0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchBackTracking.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to perform backtracking line-search.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>objective</dt><dd><p>objective function to optimise</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>manifold</dt><dd><p>manifold to optimise over</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x</dt><dd><p>starting point on the manifold</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>d</dt><dd><p>tangent vector at x (descent direction)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>df0</dt><dd><p>directional derivative at x along d</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>stepsize</dt><dd><p>norm of the vector retracted to reach newx from x</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>newx</dt><dd><p>next iterate suggested by the line-search</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.tools.autodiff">
<span id="autodiff-backends"></span><h2>Autodiff Backends<a class="headerlink" href="#module-pymanopt.tools.autodiff" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymanopt.tools.autodiff.TheanoBackend">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.tools.autodiff.</code><code class="sig-name descname">TheanoBackend</code><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.tools.autodiff._backend.Backend</span></code></p>
<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compile_function">
<code class="sig-name descname">compile_function</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend.compile_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compile_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for the theano.function(). Compiles a theano graph into a
python function.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compute_gradient">
<code class="sig-name descname">compute_gradient</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend.compute_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compute_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for theano.tensor.grad(). Computes the gradient of ‘objective’
with respect to ‘argument’ and returns compiled version.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.compute_hessian">
<code class="sig-name descname">compute_hessian</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend.compute_hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the directional derivative of the gradient (which is equal to
the Hessian multiplied by direction).</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.is_available">
<code class="sig-name descname">is_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend.is_available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.is_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TheanoBackend.is_compatible">
<code class="sig-name descname">is_compatible</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_theano.html#TheanoBackend.is_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TheanoBackend.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.tools.autodiff.AutogradBackend">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.tools.autodiff.</code><code class="sig-name descname">AutogradBackend</code><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.tools.autodiff._backend.Backend</span></code></p>
<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.compile_function">
<code class="sig-name descname">compile_function</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend.compile_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.compile_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.compute_gradient">
<code class="sig-name descname">compute_gradient</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend.compute_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.compute_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of ‘objective’ with respect to the first
argument and return as a function.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.compute_hessian">
<code class="sig-name descname">compute_hessian</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend.compute_hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.is_available">
<code class="sig-name descname">is_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend.is_available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.is_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.AutogradBackend.is_compatible">
<code class="sig-name descname">is_compatible</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_autograd.html#AutogradBackend.is_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.AutogradBackend.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymanopt.tools.autodiff.TensorflowBackend">
<em class="property">class </em><code class="sig-prename descclassname">pymanopt.tools.autodiff.</code><code class="sig-name descname">TensorflowBackend</code><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.tools.autodiff._backend.Backend</span></code></p>
<dl class="method">
<dt id="pymanopt.tools.autodiff.TensorflowBackend.compile_function">
<code class="sig-name descname">compile_function</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend.compile_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend.compile_function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TensorflowBackend.compute_gradient">
<code class="sig-name descname">compute_gradient</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend.compute_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend.compute_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of ‘objective’ and return as a function.</p>
</dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TensorflowBackend.compute_hessian">
<code class="sig-name descname">compute_hessian</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend.compute_hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend.compute_hessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TensorflowBackend.is_available">
<code class="sig-name descname">is_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend.is_available"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend.is_available" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymanopt.tools.autodiff.TensorflowBackend.is_compatible">
<code class="sig-name descname">is_compatible</code><span class="sig-paren">(</span><em class="sig-param">objective</em>, <em class="sig-param">argument</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/autodiff/_tensorflow.html#TensorflowBackend.is_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.autodiff.TensorflowBackend.is_compatible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.tools.multi">
<span id="tools"></span><h2>Tools<a class="headerlink" href="#module-pymanopt.tools.multi" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pymanopt.tools.multi.multiexp">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multiexp</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">sym=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiexp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multiexp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multieye">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multieye</code><span class="sig-paren">(</span><em class="sig-param">k</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multieye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multieye" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multilog">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multilog</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">pos_def=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multilog"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multilog" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multiprod">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multiprod</code><span class="sig-paren">(</span><em class="sig-param">A</em>, <em class="sig-param">B</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiprod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multiprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspired by MATLAB multiprod function by Paolo de Leva. A and B are
assumed to be arrays containing M matrices, that is, A and B have
dimensions A: (M, N, P), B:(M, P, Q). multiprod multiplies each matrix
in A with the corresponding matrix in B, using matrix multiplication.
so multiprod(A, B) has dimensions (M, N, Q).</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multiskew">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multiskew</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiskew"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multiskew" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multisym">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multisym</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multisym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multisym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pymanopt.tools.multi.multitransp">
<code class="sig-prename descclassname">pymanopt.tools.multi.</code><code class="sig-name descname">multitransp</code><span class="sig-paren">(</span><em class="sig-param">A</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multitransp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.multi.multitransp" title="Permalink to this definition">¶</a></dt>
<dd><p>Inspired by MATLAB multitransp function by Paolo de Leva. A is assumed to
be an array containing M matrices, each of which has dimension N x P.
That is, A is an M x N x P array. Multitransp then returns an array
containing the M matrix transposes of the matrices in A, each of which
will be P x N.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.tools.testing">
<span id="testing"></span><h2>Testing<a class="headerlink" href="#module-pymanopt.tools.testing" title="Permalink to this headline">¶</a></h2>
<p>Module containing tools for testing correctness in Pymanopt. Note, these
currently require autograd.</p>
<p>Note: the methods for generating rgrad, egrad2rgrad, ehess and ehess2rhess
will only be correct if the manifold is a submanifold of Euclidean space,
that is if the projection is an orthogonal projection onto the tangent space.</p>
<dl class="function">
<dt id="pymanopt.tools.testing.egrad2rgrad">
<code class="sig-prename descclassname">pymanopt.tools.testing.</code><code class="sig-name descname">egrad2rgrad</code><span class="sig-paren">(</span><em class="sig-param">proj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#egrad2rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.testing.egrad2rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an egrad2rgrad function.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.ehess2rhess">
<code class="sig-prename descclassname">pymanopt.tools.testing.</code><code class="sig-name descname">ehess2rhess</code><span class="sig-paren">(</span><em class="sig-param">proj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#ehess2rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.testing.ehess2rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an ehess2rhess function for a manifold which is a sub-manifold
of Euclidean space.
ehess2rhess(proj)(x, egrad, ehess, u) converts the Euclidean hessian ehess
at the point x to a Riemannian hessian. That is the directional
derivatative of the gradient in the direction u.
proj must be defined using autograd.numpy.
This will not be an efficient implementation because of missing support
for efficient jacobian-vector products in autograd.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.rgrad">
<code class="sig-prename descclassname">pymanopt.tools.testing.</code><code class="sig-name descname">rgrad</code><span class="sig-paren">(</span><em class="sig-param">cost</em>, <em class="sig-param">proj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#rgrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.testing.rgrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Riemannain gradient of cost. Cost must be defined using
autograd.numpy.</p>
</dd></dl>

<dl class="function">
<dt id="pymanopt.tools.testing.rhess">
<code class="sig-prename descclassname">pymanopt.tools.testing.</code><code class="sig-name descname">rhess</code><span class="sig-paren">(</span><em class="sig-param">cost</em>, <em class="sig-param">proj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#rhess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymanopt.tools.testing.rhess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Riemannian hessian of the cost. Specifically, rhess(cost,
proj)(x, u) is the directional derivatative of cost at point X on the
manifold, in direction u.
cost and proj must be defined using autograd.numpy.
See <a class="reference external" href="http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf">http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf</a>
for some discussion.
proj and cost must be defined using autograd.
Currently this is correct but not efficient, because of the jacobian-
vector product. Hopefully this can be fixed in future.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Pymanopt" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2020, Jamie Townsend, Niklas Koep, Sebastian Weichwald
      <span class="lastupdated">
        Last updated on Jan 23, 2020.
      </span>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>