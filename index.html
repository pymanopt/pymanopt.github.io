<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.1//EN" "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" dir="ltr" id="index">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>pymanopt</title>

    <!-- mathjax -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <!-- code-prettify -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?lang=py"></script>

    <link href="layout.css" rel="stylesheet" type="text/css" />
</head>

<body>

<p><strong>This site is under construction. Please refer to this
<a href="https://github.com/pymanopt/pymanopt">github repository</a> in
the meanwhile.</strong></p>


<h1>pymanopt</h1>

<p>pymanopt is a python toolbox for manifold optimization that computes
gradients and hessians automatically. It builds upon the MATLAB package
<a href="http://manopt.org/">Manopt</a> but is otherwise independent of
it. Pymanopt aims to lower the barriers for users wishing to use state
of the art manifold optimization techniques even further, by relying on
automatic differentiation for computing gradients and hessians, saving
users time and saving them from potential calculation and
implementiation errors.</p>

<p>pymanopt is modular and hence easy to use. Usually only the following
steps are required:</p>
<ol>
    <li>defininition of the cost function $f:\mathcal{M}\to \mathbb{R}$
    to minimise</li>
    <li>instantiation of the respective manifold $\mathcal{M}$ to optimise
    over</li>
    <li>instantiation of a pymanopt solver</li>
</ol>
<p>If needed by the solver, pymanopt will compute the gradient and
hessian automatically.</p>

<pre class="prettyprint"><code class="language-py">
import autograd.numpy as np

from pymanopt import Problem
from pymanopt.solvers import SteepestDescent
from pymanopt.manifolds import Stiefel

# (1) definition of the cost function (here using theano)
def cost(X): return np.sum(np.sum(X))

# (2) instantiation of the respective manifold
manifold = Stiefel(5, 2)

# (3) instantiation of a pymanopt solver
solver = SteepestDescent()

# let pymanopt do the rest
problem = Problem(man=manifold, cost=cost)
Xopt = solver.solve(problem)
print(Xopt)
</code></pre>


<h2>Manifolds</h2>

<table id="manifolds">

<tr>
    <th>manifold</th>
    <th>description</th>
    <th>required codelines</th>
</tr>

<tr>
    <td>Euclidean manifold $\mathbb{R}^{m\times n}$</td>
    <td>Euclidean space of $m\times n$ matrices equipped with the
    Frobenius distance and trace inner product.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Euclidean
manifold = Euclidean(m,n)
</code></pre>
    </td>
</tr>

<tr>
    <td>Sphere manifold $\mathcal{S}^m=\{x\in\mathbb{R}^{m}:||x||_2=1\}$</td>
    <td>$m\times n$ matrices of unit Frobenius norm, i.e., the unit Sphere for $n=1$ (the default value).</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Sphere
manifold = Sphere(n)
</code></pre>
    </td>
</tr>

<tr>
    <td>Stiefel manifold $\mathcal{St}^{m\times n}=\{P\in\mathbb{R}^{m\times n}: P^\top P=\mathbb{1}\}$</td>
    <td>This is the manifold of projection matrices. For optional argument $k>1$ this instantiates the product $\mathcal{St}^{m\times n}\times\cdots\times\mathcal{St}^{m\times n}$ of $k$ Stiefel manifolds.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Stiefel
manifold = Stiefel(m,n)
</code></pre>
    </td>
</tr>

<tr>
    <td>Grassmann manifold $\mathcal{Gr}^{m\times n}$</td>
    <td>This is the manifold of $n$-dimensional subspaces of $\mathbb{R}^m$. For optional argument $k>1$ this instantiates the product $\mathcal{Gr}^{m\times n}\times\cdots\times\mathcal{Gr}^{m\times n}$ of $k$ Grassmann manifolds.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Grassmann
manifold = Grassmann(m,n)
</code></pre>
    </td>
</tr>

<tr>
    <td>SymFixedRankYY manifold</td>
    <td>Manifold of $n$-by-$n$ symmetric/hermitian positive semidefinite matrices of rank $k$.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
# real
from pymanopt.manifolds import SymFixedRankYY
manifold = SymFixedRankYY(n,k)

# complex
from pymanopt.manifolds import SymFixedRankYYComplex
manifold = SymFixedRankYYComplex(n,k)
</code></pre>
    </td>
</tr>

<tr>
    <td>Elliptope manifold</td>
    <td>Manifold of $n$-by-$n$ psd matrices of rank $k$ with unit diagonal elements.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Elliptope
manifold = Elliptope(n,k)
</code></pre>
    </td>
</tr>

<tr>
    <td>Oblique manifold</td>
    <td>Manifold of matrices with unit-norm columns.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Oblique
manifold = Oblique(m,n)
</code></pre>
    </td>
</tr>

<tr class="topborder">
    <td>Product manifold</td>
    <td>Product manifold of any of the manifolds listed above, e.g. $\mathcal{St}^{m\times n}\times\mathbb{R}^{k\times l}$.</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.manifolds import Product, Stiefel, Euclidean
manifold = Product([Stiefel(m,n), Euclidean(k,l)])
</code></pre>
    </td>
</tr>

</table>

<h2>Solvers</h2>

<table id="solvers">

<tr>
    <th>solver</th>
    <th>description</th>
    <th>required codelines</th>
</tr>

<tr>
    <td>SteepestDescent</td>
    <td>Classical first-order steepest descent algorithm</td>
    <td>
<pre class="prettyprint"><code class="language-py">
from pymanopt.solvers import SteepestDescent
solver = SteepestDescent()
Xopt = solver.solve(problem)
</code></pre>
    </td>
</tr>

</table>

</body>

</html>
