<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manifolds &mdash; Pymanopt latest documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/style.css" type="text/css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" type="text/css" />
      <link rel="stylesheet" href="_static/katex-math.css" type="text/css" />
    <link rel="canonical" href="pymanopt.org/manifolds.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"></script>
        <script src="_static/katex_autorenderer.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Autodiff" href="autodiff.html" />
    <link rel="prev" title="API Reference" href="api-reference.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Pymanopt
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pymanopt/pymanopt/tree/master/examples">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api-reference.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Manifolds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.manifold">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">Euclidean Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.sphere">Sphere Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">Stiefel Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">Grassmann Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.complex_circle">Complex Circle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.special_orthogonal_group">Special Orthogonal Group</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.oblique">Oblique Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.positive_definite">Symmetric Positive Definite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.psd">Manifold of Positive Semidefinite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.fixed_rank">Fixed-Rank Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.positive">Positive Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.product">Product Manifold</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="autodiff.html">Autodiff</a></li>
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimizers.html">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Notebooks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples/notebooks/mixture_of_gaussians.html">Riemannian Optimization for Inference in MoG models</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pymanopt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="api-reference.html">API Reference</a> &raquo;</li>
      <li>Manifolds</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/manifolds.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="manifolds">
<h1>Manifolds<a class="headerlink" href="#manifolds" title="Permalink to this headline"></a></h1>
<p>The rigorous mathematical definition of a manifold is beyond the scope of this
document.
However, if you are unfamiliar with the idea, it is fine just to visualize it
as a smooth subset of <a class="reference external" href="https://en.wikipedia.org/wiki/Euclidean_space">Euclidean space</a>.
Simple examples include the surface of a sphere or a <a class="reference external" href="https://en.wikipedia.org/wiki/Torus">torus</a>, or the <a class="reference external" href="https://en.wikipedia.org/wiki/Möbius_strip">Möbius strip</a>.
For an exact definition and a general background on Riemannian optimization we
refer readers to the monographs <a class="reference internal" href="bibliography.html#ams2008" id="id1"><span>[AMS2008]</span></a> and <a class="reference internal" href="bibliography.html#bou2020" id="id2"><span>[Bou2020]</span></a> (both of which are
freely available online).
If you need to solve an optimization problem with a search space that is
constrained in some smooth way, then performing optimization on manifolds may
well be the natural approach to take.</p>
<p>The manifolds that we currently support are listed below.
We plan to implement more depending on the needs of users, so if there is a
particular manifold you would like to optimize over, please let us know.
If you wish to implement your own manifold for Pymanopt, you will
need to inherit from the abstract <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>
or <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a> base
class.</p>
<div class="section" id="module-pymanopt.manifolds.manifold">
<span id="manifold"></span><h2>Manifold<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RetrAsExpMixin">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">RetrAsExpMixin</span></span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RetrAsExpMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RetrAsExpMixin" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin which defers calls to the exponential map to the retraction.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RetrAsExpMixin.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RetrAsExpMixin.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RetrAsExpMixin.exp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Riemannian manifold base class.</p>
<p>Abstract base class setting out a template for manifold classes.</p>
<p>Not all methods are required by all optimizers.
In particular, first order gradient based optimizers such as
<a class="reference internal" href="optimizers.html#module-pymanopt.optimizers.steepest_descent" title="pymanopt.optimizers.steepest_descent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.optimizers.steepest_descent</span></code></a> and
<a class="reference internal" href="optimizers.html#module-pymanopt.optimizers.conjugate_gradient" title="pymanopt.optimizers.conjugate_gradient"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.optimizers.conjugate_gradient</span></code></a> require
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_gradient()</span></code></a> to be implemented but not
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>.
Second-order optimizers such as <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.optimizers.TrustRegions</span></code>
will require <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays.
In this case, <cite>point_layout</cite> describes how many elements such
tuples/lists contain.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.num_values">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_values</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.num_values" title="Permalink to this definition"></a></dt>
<dd><p>Total number of values representing a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.inner_product">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>numpy.ndarray</em>) – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> (<em>numpy.ndarray</em>) – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> (<em>numpy.ndarray</em>) – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.float64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.projection">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.norm">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.random_point">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.random_tangent_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.zero_vector">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.exp" title="pymanopt.manifolds.manifold.Manifold.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id3"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id4"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to <code class="docutils literal notranslate"><span class="pre">proj(point,</span> <span class="pre">vector)</span></code> but may
differ for certain manifolds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">RiemannianSubmanifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Base class for Riemannian submanifolds of Euclidean space.</p>
<p>This class provides a generic method to project Euclidean gradients to
their Riemannian counterparts via the
<a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_gradient()</span></code></a> method.
Similarly, if the Weingarten map (also known as shape operator) is provided
via implementing the <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten"><code class="xref py py-meth docutils literal notranslate"><span class="pre">weingarten()</span></code></a> method, the class provides a
generic implementation of the <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian" title="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian"><code class="xref py py-meth docutils literal notranslate"><span class="pre">euclidean_to_riemannian_hessian()</span></code></a>
method required by second-order optimizers to translate Euclidean
Hessian-vector products to their Riemannian counterparts.</p>
<p class="rubric">Notes</p>
<p>This class follows definition 3.47 in <a class="reference internal" href="bibliography.html#bou2020" id="id5"><span>[Bou2020]</span></a> of “Riemannian
submanifolds”.
As such, manifolds derived from this class are assumed to be embedded
submanifolds of Euclidean space with the Riemannian metric inherited
from the embedding space obtained by restricting it to the tangent
space at a given point.</p>
<p>For the exact definition of the Weingarten map refer to <a class="reference internal" href="bibliography.html#amt2013" id="id6"><span>[AMT2013]</span></a> and
the notes in section 5.11 of <a class="reference internal" href="bibliography.html#bou2020" id="id7"><span>[Bou2020]</span></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#RiemannianSubmanifold.weingarten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Weingarten map of the manifold.</p>
<p>This map takes a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> and a vector <code class="docutils literal notranslate"><span class="pre">normal_vector</span></code> in the normal space at
<code class="docutils literal notranslate"><span class="pre">point</span></code> to produce another tangent vector.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id8">
<h2>Euclidean Space<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2>
<span class="target" id="module-pymanopt.manifolds.euclidean"></span><dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Euclidean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Euclidean manifold.</p>
<p>Euclidean manifold of shape <code class="docutils literal notranslate"><span class="pre">(n1,</span> <span class="pre">n2,</span> <span class="pre">...,</span> <span class="pre">nk)</span></code> arrays.
Useful for unconstrained optimization problems or for unconstrained
hyperparameters as part of a product manifold.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Manifold of symmetric matrices.</p>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> symmetric matrices as a Riemannian submanifold of
Euclidean space.
If <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> then this is the product manifold of <code class="docutils literal notranslate"><span class="pre">k</span></code> symmetric <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code>
matrices represented as arrays of shape <code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n,</span> <span class="pre">n)</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">SkewSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>The Euclidean space of n-by-n skew-symmetric matrices.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.sphere">
<span id="sphere-manifold"></span><h2>Sphere Manifold<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">Sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereBase</span></code></p>
<p>The sphere manifold.</p>
<p>Manifold of shape <span class="math">\(n_1 \times n_2 \times \ldots \times n_k\)</span> tensors
with unit 2-norm.
The metric is such that the sphere is a Riemannian submanifold of Euclidean
space.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace intersection manifold.</p>
<p>Manifold of n-dimensional unit 2-norm vectors intersecting the
<span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span> spanned by the columns of
the matrix <code class="docutils literal notranslate"><span class="pre">matrix</span></code> of size <span class="math">\(n \times r\)</span>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceComplementIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceComplementIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Sphere-subspace compliment intersection manifold.</p>
<p>Manifold of n-dimensional unit 2-norm vectors which are orthogonal to
the <span class="math">\(r\)</span>-dimensional subspace of <span class="math">\(\R^n\)</span> spanned by columns of
the matrix <code class="docutils literal notranslate"><span class="pre">matrix</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.stiefel">
<span id="stiefel-manifold"></span><h2>Stiefel Manifold<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.stiefel.</span></span><span class="sig-name descname"><span class="pre">Stiefel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>The Stiefel manifold.</p>
<p>The optional argument k allows the user to optimize over the product of k
Stiefels.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id9"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id10"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.grassmann">
<span id="grassmann-manifold"></span><h2>Grassmann Manifold<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">Grassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.grassmann._GrassmannBase</span></code></p>
<p>The Grassmannian.</p>
<p>This is the manifold of p-dimensional subspaces of n dimensional real
vector space.
The optional argument k allows the user to optimize over the product of k
Grassmannians.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="pymanopt.manifolds.grassmann.Grassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">ComplexGrassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.grassmann._GrassmannBase</span></code></p>
<p>The complex Grassmannian.</p>
<p>This is the manifold of p-dimensional subspaces of n dimensional complex
vector space.
The optional argument k allows the user to optimize over the product of k
Grassmannians.
Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.ComplexGrassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#ComplexGrassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.grassmann.ComplexGrassmann.exp" title="pymanopt.manifolds.grassmann.ComplexGrassmann.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.complex_circle">
<span id="complex-circle"></span><h2>Complex Circle<a class="headerlink" href="#module-pymanopt.manifolds.complex_circle" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.complex_circle.</span></span><span class="sig-name descname"><span class="pre">ComplexCircle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of unit-modulus complex numbers.</p>
<p>Description of vectors z in C^n (complex) such that each component z(i)
has unit modulus. The manifold structure is the Riemannian submanifold
structure from the embedding space R^2 x … x R^2, i.e., the complex
circle is identified with the unit circle in the real plane.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.tangent">
<span class="sig-name descname"><span class="pre">tangent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.tangent" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.complex_circle.ComplexCircle.exp" title="pymanopt.manifolds.complex_circle.ComplexCircle.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id11"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id12"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.complex_circle.ComplexCircle.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/complex_circle.html#ComplexCircle.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.complex_circle.ComplexCircle.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.special_orthogonal_group">
<span id="special-orthogonal-group"></span><h2>Special Orthogonal Group<a class="headerlink" href="#module-pymanopt.manifolds.special_orthogonal_group" title="Permalink to this headline"></a></h2>
<p>Module containing manifolds of n-dimensional rotations.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.special_orthogonal_group.</span></span><span class="sig-name descname"><span class="pre">SpecialOrthogonalGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">retraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'qr'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>The special orthogonal group.</p>
<p>Special orthogonal group (the manifold of rotations): deals with matrices
X of size k x n x n (or n x n if k = 1, which is the default) such that
each n x n matrix is orthogonal, with determinant 1, i.e.,
dot(X.T, X) = eye(n) if k = 1, or dot(X[i].T, X[i]) = eye(n) if k &gt; 1.</p>
<p>This is a description of SO(n)^k with the induced metric from the
embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
submanifold of (R^nxn)^k endowed with the usual trace inner product.</p>
<p>Tangent vectors are represented in the Lie algebra, i.e., as skew
symmetric matrices. Use the function manifold.embedding(X, H) to
switch from the Lie algebra representation to the embedding space
representation. This is often necessary when defining
<code class="docutils literal notranslate"><span class="pre">problem.euclidean_hessian</span></code>.</p>
<p>By default, the retraction is only a first-order approximation of the
exponential. To force the use of a second-order approximation, instantiate
the class with <code class="docutils literal notranslate"><span class="pre">SpecialOrthogonalGroup(n,</span> <span class="pre">k,</span> <span class="pre">retraction=&quot;polar&quot;)</span></code>.
This switches from a QR-based computation to an SVD-based computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – The dimension of the space that elements of the group act on.</p></li>
<li><p><strong>k</strong> – The number of elements in the product of groups.</p></li>
<li><p><strong>retraction</strong> – The type of retraction to use.
Possible choices are <code class="docutils literal notranslate"><span class="pre">qr</span></code> and <code class="docutils literal notranslate"><span class="pre">polar</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The procedure to generate random rotation matrices sampled uniformly
from the Haar measure is detailed in <a class="reference internal" href="bibliography.html#mez2006" id="id13"><span>[Mez2006]</span></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Re-tangentialize a vector.</p>
<p>This method guarantees that <code class="docutils literal notranslate"><span class="pre">vector</span></code> is indeed a tangent vector
at <code class="docutils literal notranslate"><span class="pre">point</span></code> on the manifold.
Typically this simply corresponds to <code class="docutils literal notranslate"><span class="pre">proj(point,</span> <span class="pre">vector)</span></code> but may
differ for certain manifolds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.embedding" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp" title="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id14"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id15"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/special_orthogonal_group.html#SpecialOrthogonalGroup.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.special_orthogonal_group.SpecialOrthogonalGroup.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.oblique">
<span id="oblique-manifold"></span><h2>Oblique Manifold<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.oblique.</span></span><span class="sig-name descname"><span class="pre">Oblique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of matrices with unit-norm columns.</p>
<p>Oblique manifold: deals with matrices of size m-by-n such that each column
has unit 2-norm, i.e., is a point on the unit sphere in R^m. The metric
is such that the oblique manifold is a Riemannian submanifold of the
space of m-by-n matrices with the usual trace inner product.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.oblique.Oblique.exp" title="pymanopt.manifolds.oblique.Oblique.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id16"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id17"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.positive_definite">
<span id="symmetric-positive-definite-matrices"></span><h2>Symmetric Positive Definite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.positive_definite" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.positive_definite.</span></span><span class="sig-name descname"><span class="pre">SymmetricPositiveDefinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of symmetric positive definite matrices.</p>
<p class="rubric">Notes</p>
<p>The geometry is based on the discussion in chapter 6 of <a class="reference internal" href="bibliography.html#bha2007" id="id18"><span>[Bha2007]</span></a>.
Also see <a class="reference internal" href="bibliography.html#sh2015" id="id19"><span>[SH2015]</span></a> for more details.</p>
<p>The second-order retraction is taken from <span id="id20">[JVV20212]</span>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id21"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id22"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp" title="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive_definite.html#SymmetricPositiveDefinite.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive_definite.SymmetricPositiveDefinite.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.psd">
<span id="manifold-of-positive-semidefinite-matrices"></span><h2>Manifold of Positive Semidefinite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank positive semidefinite (PSD) matrices.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may
be big). Tangent vectors are represented as matrices of the same size as
Y, call them Ydot, so that Xdot = Y Ydot’ + Ydot Y. The metric is the
canonical Euclidean metric on Y.</p>
<p>Since for any orthogonal Q of size k, it holds that (YQ)(YQ)’ = YY’,
we “group” all matrices of the form YQ in an equivalence class. The set
of equivalence classes is a Riemannian quotient manifold, implemented
here.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<p>An alternative, complete, geometry for positive semidefinite matrices of
rank k is described in Bonnabel and Sepulchre 2009, “Riemannian Metric
and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank”,
SIAM Journal on Matrix Analysis and Applications.</p>
<p>The geometry implemented here is the simplest case of the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRankComplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of fixed-rank Hermitian positive semidefinite (PSD) matrices.</p>
<p>Manifold of n-by-n complex Hermitian positive semidefinite matrices of
fixed rank k. This follows the quotient geometry described
in Sarod Yatawatta’s 2013 paper:
“Radio interferometric calibration using a Riemannian manifold”, ICASSP.</p>
<p>Paper link: <a class="reference external" href="http://dx.doi.org/10.1109/ICASSP.2013.6638382">http://dx.doi.org/10.1109/ICASSP.2013.6638382</a>.</p>
<p>A point X on the manifold M is parameterized as YY^*, where Y is a
complex matrix of size nxk of full rank. For any point Y on the manifold M,
given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y,
i.e., YY^* does not change. Therefore, M is the set of equivalence
classes and is a Riemannian quotient manifold C^{nk}/U(k)
where C^{nk} is the set of all complex matrix of size nxk of full rank.
The metric is the usual real trace inner product, that is,
it is the usual metric for the complex plane identified with R^2.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">Elliptope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>, <a class="reference internal" href="#pymanopt.manifolds.manifold.RetrAsExpMixin" title="pymanopt.manifolds.manifold.RetrAsExpMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RetrAsExpMixin</span></code></a></p>
<p>Manifold of fixed-rank PSD matrices with unit diagonal elements.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may be
big). Tangent vectors are represented as matrices of the same size as Y,
call them Ydot, so that Xdot = Y Ydot’ + Ydot Y and diag(Xdot) == 0. The
metric is the canonical Euclidean metric on Y.</p>
<p>The diagonal constraints on X (X(i, i) == 1 for all i) translate to
unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.  The
set of such Y’s forms the oblique manifold. But because for any orthogonal
Q of size k, it holds that (YQ)(YQ)’ = YY’, we “group” all matrices of the
form YQ in an equivalence class. The set of equivalence classes is a
Riemannian quotient manifold, implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient Y’s.  This
does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient Y’s, but convergence theorems no
longer hold. As an alternative, you may use the oblique manifold (it has
larger dimension, but does not break down at rank drop.)</p>
<p>The geometry is taken from the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id23"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id24"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.fixed_rank">
<span id="fixed-rank-matrices"></span><h2>Fixed-Rank Matrices<a class="headerlink" href="#module-pymanopt.manifolds.fixed_rank" title="Permalink to this headline"></a></h2>
<p>Module containing manifolds of fixed-rank matrices.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.fixed_rank.</span></span><span class="sig-name descname"><span class="pre">FixedRankEmbedded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.RiemannianSubmanifold" title="pymanopt.manifolds.manifold.RiemannianSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.RiemannianSubmanifold</span></code></a></p>
<p>Manifold of fixed rank matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows of the matrices in the ambient space.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns of the matrices.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The rank of the matrices on the manifold.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The implementation follows the embedded geometry described in
<a class="reference internal" href="bibliography.html#van2013" id="id25"><span>[Van2013]</span></a>.</p></li>
<li><p>The class is currently not compatible with the
<code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.optimizers.TrustRegions</span></code> optimizer.</p></li>
</ul>
<p>Manifold of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> real matrices of fixed rank <code class="docutils literal notranslate"><span class="pre">k</span></code>.
For efficiency purposes, Pymanopt does not represent points on this
manifold explicitly using <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices, but instead implicitly using
a truncated singular value decomposition.
Specifically, a point is represented by a tuple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">s,</span> <span class="pre">vt)</span></code> of three
numpy arrays.
The arrays <code class="docutils literal notranslate"><span class="pre">u</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">vt</span></code> have shapes <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">k)</span></code>, <code class="docutils literal notranslate"><span class="pre">(k,)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(k,</span> <span class="pre">n)</span></code>, respectively, and the low rank matrix which they represent can
be recovered by the matrix product <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">*</span> <span class="pre">diag(s)</span> <span class="pre">*</span> <span class="pre">vt</span></code>.</p>
<p>For example, to optimize over the space of 5 x 4 matrices with rank 3, we</p>
<p>would need to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pymanopt.manifolds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">manifold</span> <span class="o">=</span> <span class="n">pymanopt</span><span class="o">.</span><span class="n">manifolds</span><span class="o">.</span><span class="n">FixedRankEmbedded</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the shapes will be as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">manifold</span><span class="o">.</span><span class="n">random_point</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vt</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4)</span>
</pre></div>
</div>
<p>and the full matrix can be recovered using the matrix product
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">&#64;</span> <span class="pre">diag(s)</span> <span class="pre">&#64;</span> <span class="pre">vt</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">u</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">@</span> <span class="n">vt</span>
</pre></div>
</div>
<p>Tangent vectors are represented as a tuple <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code>.
The matrices <code class="docutils literal notranslate"><span class="pre">Up</span></code> (of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">k</span></code>) and <code class="docutils literal notranslate"><span class="pre">Vp</span></code> (of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">k</span></code>) obey
<code class="docutils literal notranslate"><span class="pre">Up'</span> <span class="pre">*</span> <span class="pre">U</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">and</span> <span class="pre">Vp'</span> <span class="pre">*</span> <span class="pre">V</span> <span class="pre">=</span> <span class="pre">0</span></code>.
The matrix <code class="docutils literal notranslate"><span class="pre">M</span></code> (of size <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">k</span></code>) is arbitrary.
Such a structure corresponds to the
following tangent vector in the ambient space of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices: <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span>
<span class="pre">U</span> <span class="pre">*</span> <span class="pre">M</span> <span class="pre">*</span> <span class="pre">V'</span> <span class="pre">+</span> <span class="pre">Up</span> <span class="pre">*</span> <span class="pre">V'</span> <span class="pre">+</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">Vp'</span></code>
where <code class="docutils literal notranslate"><span class="pre">(U,</span> <span class="pre">S,</span> <span class="pre">V)</span></code> is the current point and <code class="docutils literal notranslate"><span class="pre">(Up,</span> <span class="pre">M,</span> <span class="pre">Vp)</span></code> is the tangent
vector at that point.</p>
<p>Vectors in the ambient space are best represented as <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrices.
If these are low-rank, they may also be represented as structures with
<code class="docutils literal notranslate"><span class="pre">U,</span> <span class="pre">S,</span> <span class="pre">V</span></code> fields, such that <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">U</span> <span class="pre">*</span> <span class="pre">S</span> <span class="pre">*</span> <span class="pre">V'</span></code>.
There are no restrictions on what <code class="docutils literal notranslate"><span class="pre">U</span></code>, <code class="docutils literal notranslate"><span class="pre">S</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code> are, as long as
their product as indicated yields a real <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix.</p>
<p>The chosen geometry yields a Riemannian submanifold of the embedding
space <span class="math">\(\R^(m \times n)\)</span> equipped with the usual trace (Frobenius)
inner product.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.projection" title="Permalink to this definition"></a></dt>
<dd><p>Project vector to tangent space.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">vector</span></code> must either be an m x n matrix from the ambient
space, or else a tuple (Uz, Sz, Vz), where Uz * Sz * Vz is in the
ambient space (of low-rank matrices).
This function then returns a tangent vector parameterized as
(Up, M, Vp).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Convert Euclidean to Riemannian gradient.</p>
<p>Assuming that the cost function being optimized has been defined
in terms of the low-rank singular value decomposition, the
gradient returned by the autodiff backends will have three components
and will be in the form of a tuple <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span> <span class="pre">=</span> <span class="pre">(df/dU,</span>
<span class="pre">df/dS,</span> <span class="pre">df/dV)</span></code>.</p>
<p class="rubric">Notes</p>
<p>See <a class="reference external" href="https://j-towns.github.io/papers/svd-derivative.pdf">https://j-towns.github.io/papers/svd-derivative.pdf</a> for a
detailed explanation of this implementation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.to_tangent_space">
<span class="sig-name descname"><span class="pre">to_tangent_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.to_tangent_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.to_tangent_space" title="Permalink to this definition"></a></dt>
<dd><p>Project components of <code class="docutils literal notranslate"><span class="pre">vector</span></code> to tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">vector</span></code> in tangent vector format, projects its components Up
and Vp such that they satisfy the tangent space constraints up to
numerical errors.
If <code class="docutils literal notranslate"><span class="pre">vector</span></code> was already in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>, this
method should barely have any effect.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.embedding">
<span class="sig-name descname"><span class="pre">embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.embedding" title="Permalink to this definition"></a></dt>
<dd><p>Represent tangent vector in ambient space.</p>
<p>Transforms a tangent vector Z represented as a structure (Up, M, Vp)
into a structure with fields (U, S, V) that represents that same
tangent vector in the ambient space of mxn matrices, as U*S*V’.
This matrix is equal to X.U*Z.M*X.V’ + Z.Up*X.V’ + X.U*Z.Vp’.
The latter is an mxn matrix, which could be too large to build
explicitly, and this is why we return a low-rank representation
instead.
Note that there are no guarantees on U, S and V other than that USV’ is
the desired matrix.
In particular, U and V are not (in general) orthonormal and S is not
(in general) diagonal.
Currently, S is identity, but this might change.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id26"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id27"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/fixed_rank.html#FixedRankEmbedded.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.fixed_rank.FixedRankEmbedded.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.positive">
<span id="positive-matrices"></span><h2>Positive Matrices<a class="headerlink" href="#module-pymanopt.manifolds.positive" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.positive.</span></span><span class="sig-name descname"><span class="pre">Positive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_parallel_transport</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>The (product) manifold of positive matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of rows.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of columns.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – The number of matrices in the product.</p></li>
<li><p><strong>use_parallel_transport</strong> (<em>bool</em>) – Flag whether to use a parallel transport for
<a class="reference internal" href="#pymanopt.manifolds.positive.Positive.transport" title="pymanopt.manifolds.positive.Positive.transport"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transport()</span></code></a> or a transporter (the default).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Points on the manifold are represented as arrays of size <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>
(when <code class="docutils literal notranslate"><span class="pre">k</span></code> is 1), and <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> otherwise.</p>
<p>The tangent spaces of the manifold correspond to copies of <span class="math">\(\R^{m
\times n}\)</span>.
As such, tangent vectors are represented as arrays of the same shape as
points on the manifold without any positivity constraints on the
individual elements.</p>
<p>The Riemannian metric is the bi-invariant metric for positive definite
matrices from chapter 6 of <a class="reference internal" href="bibliography.html#bha2007" id="id28"><span>[Bha2007]</span></a> on individual scalar coordinates
of matrices.
See also section 11.4 of <a class="reference internal" href="bibliography.html#bou2020" id="id29"><span>[Bou2020]</span></a> for further details.</p>
<p>The second-order retraction is taken from <span id="id30">[JVV20212]</span>.</p>
<p>The parallel transport that is used when <code class="docutils literal notranslate"><span class="pre">use_parallel_transport</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code> is taken from <a class="reference internal" href="bibliography.html#sh2015" id="id31"><span>[SH2015]</span></a>.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.positive.Positive.exp" title="pymanopt.manifolds.positive.Positive.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.positive.Positive.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/positive.html#Positive.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.positive.Positive.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id32"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id33"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymanopt.manifolds.product">
<span id="product-manifold"></span><h2>Product Manifold<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.product.</span></span><span class="sig-name descname"><span class="pre">Product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifolds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Product manifold, i.e., the cartesian product of multiple manifolds.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.typical_dist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typical_dist</span></span><a class="headerlink" href="#pymanopt.manifolds.product.Product.typical_dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the <cite>scale</cite> of the manifold.</p>
<p>This is used by the trust-regions optimizer to determine default
initial and maximal trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector at a point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.inner_product">
<span class="sig-name descname"><span class="pre">inner_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.inner_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.inner_product" title="Permalink to this definition"></a></dt>
<dd><p>Inner product between tangent vectors at a point on the manifold.</p>
<p>This method implements a Riemannian inner product between two tangent
vectors <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and <code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent
space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> – The base point.</p></li>
<li><p><strong>tangent_vector_a</strong> – The first tangent vector.</p></li>
<li><p><strong>tangent_vector_b</strong> – The second tangent vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The inner product between <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> and
<code class="docutils literal notranslate"><span class="pre">tangent_vector_b</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.dist" title="Permalink to this definition"></a></dt>
<dd><p>The geodesic distance between two points on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.projection">
<span class="sig-name descname"><span class="pre">projection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.projection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.projection" title="Permalink to this definition"></a></dt>
<dd><p>Projects vector in the ambient space on the tangent space.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.euclidean_to_riemannian_gradient">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.euclidean_to_riemannian_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.euclidean_to_riemannian_gradient" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian gradient.</p>
<p>For embedded submanifolds of Euclidean space, this is simply the
projection of <code class="docutils literal notranslate"><span class="pre">euclidean_gradient</span></code> on the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.euclidean_to_riemannian_hessian">
<span class="sig-name descname"><span class="pre">euclidean_to_riemannian_hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">euclidean_hessian</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.euclidean_to_riemannian_hessian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.euclidean_to_riemannian_hessian" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean to the Riemannian Hessian.</p>
<p>This converts the Euclidean Hessian-vector product (hvp)
<code class="docutils literal notranslate"><span class="pre">euclidean_hessian</span></code> of a function at a point <code class="docutils literal notranslate"><span class="pre">point</span></code> along a tangent
vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> to the Riemannian hvp of <code class="docutils literal notranslate"><span class="pre">point</span></code> along
<code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the exponential map on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.retraction">
<span class="sig-name descname"><span class="pre">retraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.retraction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.retraction" title="Permalink to this definition"></a></dt>
<dd><p>Retracts a tangent vector back to the manifold.</p>
<p>This generalizes the exponential map, and is often more efficient to
compute numerically.
It maps a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector</span></code> in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>
back to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the logarithmic map on the manifold.</p>
<p>The logarithmic map <code class="docutils literal notranslate"><span class="pre">log(point_a,</span> <span class="pre">point_b)</span></code> produces a tangent vector
in the tangent space at <code class="docutils literal notranslate"><span class="pre">point_a</span></code> that points in the direction of
<code class="docutils literal notranslate"><span class="pre">point_b</span></code>.
In other words, <code class="docutils literal notranslate"><span class="pre">exp(point_a,</span> <span class="pre">log(point_a,</span> <span class="pre">point_b))</span> <span class="pre">==</span> <span class="pre">point_b</span></code>.
As such it is the inverse of <a class="reference internal" href="#pymanopt.manifolds.product.Product.exp" title="pymanopt.manifolds.product.Product.exp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.random_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.random_tangent_vector">
<span class="sig-name descname"><span class="pre">random_tangent_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.random_tangent_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.random_tangent_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.transport">
<span class="sig-name descname"><span class="pre">transport</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tangent_vector_a</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.transport"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.transport" title="Permalink to this definition"></a></dt>
<dd><p>Compute transport of tangent vectors between tangent spaces.</p>
<p>This may either be a vector transport (a generalization of parallel
transport) as defined in section 8.1 of <a class="reference internal" href="bibliography.html#ams2008" id="id34"><span>[AMS2008]</span></a>, or a transporter
(see e.g. section 10.5 of <a class="reference internal" href="bibliography.html#bou2020" id="id35"><span>[Bou2020]</span></a>).
It transports a vector <code class="docutils literal notranslate"><span class="pre">tangent_vector_a</span></code> in the tangent space at
<code class="docutils literal notranslate"><span class="pre">point_a</span></code> to the tangent space at <cite>point_b</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.pair_mean">
<span class="sig-name descname"><span class="pre">pair_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.pair_mean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.pair_mean" title="Permalink to this definition"></a></dt>
<dd><p>Computes the intrinsic mean of two points on the manifold.</p>
<p>Returns the intrinsic mean of two points <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on the
manifold, i.e., a point that lies mid-way between <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> on
the geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.zero_vector">
<span class="sig-name descname"><span class="pre">zero_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.zero_vector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.zero_vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api-reference.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="autodiff.html" class="btn btn-neutral float-right" title="Autodiff" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, Jamie Townsend, Niklas Koep, Sebastian Weichwald.
      <span class="lastupdated">Last updated on May 05, 2022.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: latest
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      <dd><a href="/docs/latest">latest</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>