<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; Pymanopt latest documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="pymanopt.org/api-reference.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Pymanopt" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Pymanopt
          </a>
              <div class="version">
                latest
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.core.problem">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="#manifolds">Manifolds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.manifold">Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.euclidean">Euclidean Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.grassmann">The Grassmann Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.oblique">The Oblique Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.product">The Product Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.psd">The Manifolds of Positive Semidefinite Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.sphere">The Sphere Manifold</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.manifolds.stiefel">The Stiefel Manifold</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solvers">Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.solver">Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.conjugate_gradient">Riemannian Conjugate Gradients</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.nelder_mead">The Nelder-Mead Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.particle_swarm">Particle Swarms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.steepest_descent">The Riemannian Steepest Descent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pymanopt.solvers.trust_regions">Second-Order Riemannian Trust Regions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.solvers.linesearch">Line-Search Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#autodiff-backends">Autodiff Backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.tools.multi">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pymanopt.tools.testing">Testing</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pymanopt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api-reference.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline"></a></h1>
<section id="module-pymanopt.core.problem">
<span id="problem"></span><h2>Problem<a class="headerlink" href="#module-pymanopt.core.problem" title="Permalink to this headline"></a></h2>
<p>Module containing pymanopt problem class. Use this to build a problem
object to feed to one of the solvers.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.core.problem.</span></span><span class="sig-name descname"><span class="pre">Problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/core/problem.html#Problem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.core.problem.Problem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Problem class for setting up a problem to feed to one of the
pymanopt solvers.</p>
<dl class="simple">
<dt>Attributes:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>manifold</dt><dd><p>Manifold to optimize over.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cost</dt><dd><p>A callable which takes an element of manifold and returns a
real number, or a symbolic Theano or TensorFlow expression.
In case of a symbolic expression, the gradient (and if
necessary the Hessian) are computed automatically if they are
not explicitly given. We recommend you take this approach
rather than calculating gradients and Hessians by hand.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>grad</dt><dd><p>grad(x) is the gradient of cost at x. This must take an
element X of manifold and return an element of the tangent space
to manifold at X. This is usually computed automatically and
doesn’t need to be set by the user.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>hess</dt><dd><p>hess(x, a) is the directional derivative of grad at x, in
direction a. It should return an element of the tangent
space to manifold at x.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>egrad</dt><dd><p>The ‘Euclidean gradient’, egrad(x) should return the grad of
cost in the usual sense, i.e. egrad(x) need not lie in the
tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ehess</dt><dd><p>The ‘Euclidean Hessian’, ehess(x, a) should return the
directional derivative of egrad at x in direction a. This
need not lie in the tangent space.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>verbosity (2)</dt><dd><p>Level of information printed by the solver while it operates, 0
is silent, 2 is most information.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem.cost">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">cost</span></span><a class="headerlink" href="#pymanopt.core.problem.Problem.cost" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem.egrad">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">egrad</span></span><a class="headerlink" href="#pymanopt.core.problem.Problem.egrad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem.grad">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">grad</span></span><a class="headerlink" href="#pymanopt.core.problem.Problem.grad" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem.ehess">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">ehess</span></span><a class="headerlink" href="#pymanopt.core.problem.Problem.ehess" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.core.problem.Problem.hess">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">hess</span></span><a class="headerlink" href="#pymanopt.core.problem.Problem.hess" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="manifolds">
<h2>Manifolds<a class="headerlink" href="#manifolds" title="Permalink to this headline"></a></h2>
<section id="module-pymanopt.manifolds.manifold">
<span id="manifold"></span><h3>Manifold<a class="headerlink" href="#module-pymanopt.manifolds.manifold" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">Manifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class setting out a template for manifold classes. If you
would like to extend Pymanopt with a new manifold, then your manifold
should inherit from this class.</p>
<p>Not all methods are required by all solvers. In particular, first order
gradient based solvers such as
<a class="reference internal" href="#module-pymanopt.solvers.steepest_descent" title="pymanopt.solvers.steepest_descent"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.steepest_descent</span></code></a> and
<a class="reference internal" href="#module-pymanopt.solvers.conjugate_gradient" title="pymanopt.solvers.conjugate_gradient"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.conjugate_gradient</span></code></a> require
<a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="pymanopt.manifolds.manifold.Manifold.egrad2rgrad"><code class="xref py py-func docutils literal notranslate"><span class="pre">egrad2rgrad()</span></code></a> to be implemented but not <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-func docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.
Second order solvers such as <a class="reference internal" href="#module-pymanopt.solvers.trust_regions" title="pymanopt.solvers.trust_regions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pymanopt.solvers.trust_regions</span></code></a>
will require <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="pymanopt.manifolds.manifold.Manifold.ehess2rhess"><code class="xref py py-func docutils literal notranslate"><span class="pre">ehess2rhess()</span></code></a>.</p>
<p>All of these methods correspond closely to methods in
<a class="reference external" href="http://www.manopt.org">Manopt</a>. See
<a class="reference external" href="http://www.manopt.org/tutorial.html#manifolds">http://www.manopt.org/tutorial.html#manifolds</a> for more details on manifolds
in Manopt, which are effectively identical to those in Pymanopt (all of the
methods in this class have equivalents in Manopt with the same name).</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dim">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dim" title="Permalink to this definition"></a></dt>
<dd><p>The dimension of the manifold</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.point_layout">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">point_layout</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.point_layout" title="Permalink to this definition"></a></dt>
<dd><p>The number of elements a point on a manifold consists of.</p>
<p>For most manifolds, which represent points as (potentially
multi-dimensional) arrays, this will be 1, but other manifolds might
represent points as tuples or lists of arrays. In this case,
<cite>point_layout</cite> describes how many elements such tuples/lists contain.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.inner">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.proj">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.norm">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.rand">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.randvec">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.zerovec">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic logarithm of <cite>Y</cite>. This is the inverse of
<cite>exp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.Manifold.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#Manifold.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.Manifold.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intrinsic mean of two points <cite>X</cite> and <cite>Y</cite> on the
manifold, i.e., a point that lies mid-way between <cite>X</cite> and <cite>Y</cite> on the
geodesic arc joining them.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.manifold.</span></span><span class="sig-name descname"><span class="pre">EuclideanEmbeddedSubmanifold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_layout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>A class to model embedded submanifolds of a Euclidean space. It provides
a generic way to project Euclidean gradients to their Riemannian
counterparts via the <cite>egrad2rgrad</cite> method. Similarly, if the Weingarten map
(also known as shape operator) is provided via implementing the
‘weingarten’ method, the class provides a generic implementation of the
‘ehess2rhess’ method required by second-order solvers to translate
Euclidean Hessian-vector products to their Riemannian counterparts.</p>
<p>Refer to <a href="#id5"><span class="problematic" id="id1">[1]_</span></a> for the exact definition of the Weingarten map.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p>Absil, P-A., Robert Mahony, and Jochen Trumpf. “An extrinsic look at
the Riemannian Hessian.” International Conference on Geometric Science
of Information. Springer, Berlin, Heidelberg, 2013.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten">
<span class="sig-name descname"><span class="pre">weingarten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/manifold.html#EuclideanEmbeddedSubmanifold.weingarten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold.weingarten" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the Weingarten map of the manifold. This map takes a
vector <cite>U</cite> in the tangent space at <cite>X</cite> and a vector <cite>V</cite> in the
normal space at <cite>X</cite> to produce another tangent vector.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.euclidean">
<span id="euclidean-space"></span><h3>Euclidean Space<a class="headerlink" href="#module-pymanopt.manifolds.euclidean" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Euclidean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Euclidean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Euclidean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Euclidean" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Euclidean manifold of shape n1 x n2 x … x nk tensors. Useful for
unconstrained optimization problems or for unconstrained hyperparameters,
as part of a product manifold.</p>
<p>Examples:
Create a manifold of vectors of length n:
manifold = Euclidean(n)</p>
<p>Create a manifold of m x n matrices:
manifold = Euclidean(m, n)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">Symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>Manifold of n x n symmetric matrices, as a Riemannian submanifold of
Euclidean space.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.Symmetric.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#Symmetric.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.Symmetric.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.euclidean.</span></span><span class="sig-name descname"><span class="pre">SkewSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.euclidean._Euclidean</span></code></p>
<p>The Euclidean space of n-by-n skew-symmetric matrices.</p>
<p>If k &gt; 1 then this is an array of shape (k, n, n) (product manifold)
containing k (n x n) matrices.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.euclidean.SkewSymmetric.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/euclidean.html#SkewSymmetric.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.euclidean.SkewSymmetric.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.grassmann">
<span id="the-grassmann-manifold"></span><h3>The Grassmann Manifold<a class="headerlink" href="#module-pymanopt.manifolds.grassmann" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.grassmann.</span></span><span class="sig-name descname"><span class="pre">Grassmann</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Factory class for the Grassmann manifold. This is the manifold of p-
dimensional subspaces of n dimensional real vector space. Initiation
requires the dimensions n, p to be specified. Optional argument k
allows the user to optimize over the product of k Grassmanns.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic logarithm of <cite>Y</cite>. This is the inverse of
<cite>exp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.grassmann.Grassmann.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/grassmann.html#Grassmann.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.grassmann.Grassmann.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.oblique">
<span id="the-oblique-manifold"></span><h3>The Oblique Manifold<a class="headerlink" href="#module-pymanopt.manifolds.oblique" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.oblique.</span></span><span class="sig-name descname"><span class="pre">Oblique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of matrices w/ unit-norm columns.</p>
<p>Oblique manifold: deals with matrices of size m-by-n such that each column
has unit 2-norm, i.e., is a point on the unit sphere in R^m. The metric
is such that the oblique manifold is a Riemannian submanifold of the
space of m-by-n matrices with the usual trace inner product, i.e., the
usual metric.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic logarithm of <cite>Y</cite>. This is the inverse of
<cite>exp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intrinsic mean of two points <cite>X</cite> and <cite>Y</cite> on the
manifold, i.e., a point that lies mid-way between <cite>X</cite> and <cite>Y</cite> on the
geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.oblique.Oblique.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/oblique.html#Oblique.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.oblique.Oblique.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.product">
<span id="the-product-manifold"></span><h3>The Product Manifold<a class="headerlink" href="#module-pymanopt.manifolds.product" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.product.</span></span><span class="sig-name descname"><span class="pre">Product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifolds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a></p>
<p>Product manifold, i.e., the cartesian product of multiple manifolds.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.product.Product.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic logarithm of <cite>Y</cite>. This is the inverse of
<cite>exp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.pairmean">
<span class="sig-name descname"><span class="pre">pairmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.pairmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.pairmean" title="Permalink to this definition"></a></dt>
<dd><p>Returns the intrinsic mean of two points <cite>X</cite> and <cite>Y</cite> on the
manifold, i.e., a point that lies mid-way between <cite>X</cite> and <cite>Y</cite> on the
geodesic arc joining them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.product.Product.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/product.html#Product.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.product.Product.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.psd">
<span id="the-manifolds-of-positive-semidefinite-matrices"></span><h3>The Manifolds of Positive Semidefinite Matrices<a class="headerlink" href="#module-pymanopt.manifolds.psd" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">SymmetricPositiveDefinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Manifold of (n x n)^k symmetric positive definite matrices, based on the
geometry discussed in Chapter 6 of Positive Definite Matrices (Bhatia
2007). Some of the implementation is based on sympositivedefinitefactory.m
from the Manopt MATLAB package. Also see “Conic geometric optimisation on
the manifold of positive definite matrices” (Sra &amp; Hosseini 2013) for more
details.</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.log">
<span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.log" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic logarithm of <cite>Y</cite>. This is the inverse of
<cite>exp</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.SymmetricPositiveDefinite.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#SymmetricPositiveDefinite.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.SymmetricPositiveDefinite.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRank">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRank" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of n-by-n symmetric positive semidefinite matrices of rank k.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may
be big). Tangent vectors are represented as matrices of the same size as
Y, call them Ydot, so that Xdot = Y Ydot’ + Ydot Y. The metric is the
canonical Euclidean metric on Y.</p>
<p>Since for any orthogonal Q of size k, it holds that (YQ)(YQ)’ = YY’,
we “group” all matrices of the form YQ in an equivalence class. The set
of equivalence classes is a Riemannian quotient manifold, implemented
here.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<p>An alternative, complete, geometry for positive semidefinite matrices of
rank k is described in Bonnabel and Sepulchre 2009, “Riemannian Metric
and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank”,
SIAM Journal on Matrix Analysis and Applications.</p>
<p>The geometry implemented here is the simplest case of the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">PSDFixedRankComplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._PSDFixedRank</span></code></p>
<p>Manifold of n x n complex Hermitian pos. semidefinite matrices of rank k.</p>
<p>Manifold of n-by-n complex Hermitian positive semidefinite matrices of
fixed rank k. This follows the quotient geometry described
in Sarod Yatawatta’s 2013 paper:
“Radio interferometric calibration using a Riemannian manifold”, ICASSP.</p>
<p>Paper link: <a class="reference external" href="http://dx.doi.org/10.1109/ICASSP.2013.6638382">http://dx.doi.org/10.1109/ICASSP.2013.6638382</a>.</p>
<p>A point X on the manifold M is parameterized as YY^*, where Y is a
complex matrix of size nxk of full rank. For any point Y on the manifold M,
given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y,
i.e., YY^* does not change. Therefore, M is the set of equivalence
classes and is a Riemannian quotient manifold C^{nk}/U(k)
where C^{nk} is the set of all complex matrix of size nxk of full rank.
The metric is the usual real-trace inner product, that is,
it is the usual metric for the complex plane identified with R^2.</p>
<p>Notice that this manifold is not complete: if optimization leads Y to be
rank-deficient, the geometry will break down. Hence, this geometry should
only be used if it is expected that the points of interest will have rank
exactly k. Reduce k if that is not the case.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.dist">
<span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.dist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the geodesic distance between two points <cite>X</cite> and <cite>Y</cite> on the
manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.PSDFixedRankComplex.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#PSDFixedRankComplex.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.PSDFixedRankComplex.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.psd.</span></span><span class="sig-name descname"><span class="pre">Elliptope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.Manifold" title="pymanopt.manifolds.manifold.Manifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.Manifold</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.psd._RetrAsExpMixin</span></code></p>
<p>Manifold of n-by-n psd matrices of rank k with unit diagonal elements.</p>
<p>A point X on the manifold is parameterized as YY^T where Y is a matrix of
size nxk. As such, X is symmetric, positive semidefinite. We restrict to
full-rank Y’s, such that X has rank exactly k. The point X is numerically
represented by Y (this is more efficient than working with X, which may be
big). Tangent vectors are represented as matrices of the same size as Y,
call them Ydot, so that Xdot = Y Ydot’ + Ydot Y and diag(Xdot) == 0. The
metric is the canonical Euclidean metric on Y.</p>
<p>The diagonal constraints on X (X(i, i) == 1 for all i) translate to
unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.  The
set of such Y’s forms the oblique manifold. But because for any orthogonal
Q of size k, it holds that (YQ)(YQ)’ = YY’, we “group” all matrices of the
form YQ in an equivalence class. The set of equivalence classes is a
Riemannian quotient manifold, implemented here.</p>
<p>Note that this geometry formally breaks down at rank-deficient Y’s.  This
does not appear to be a major issue in practice when optimization
algorithms converge to rank-deficient Y’s, but convergence theorems no
longer hold. As an alternative, you may use the oblique manifold (it has
larger dimension, but does not break down at rank drop.)</p>
<p>The geometry is taken from the 2010 paper:
M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
“Low-Rank Optimization on the Cone of Positive Semidefinite Matrices”.
Paper link: <a class="reference external" href="http://www.di.ens.fr/~fbach/journee2010_sdp.pdf">http://www.di.ens.fr/~fbach/journee2010_sdp.pdf</a></p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.egrad2rgrad">
<span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Maps the Euclidean gradient <cite>G</cite> in the ambient space on the tangent
space of the manifold at <cite>X</cite>. For embedded submanifolds, this is simply
the projection of <cite>G</cite> on the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.psd.Elliptope.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/psd.html#Elliptope.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.psd.Elliptope.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.manifolds.sphere">
<span id="the-sphere-manifold"></span><h3>The Sphere Manifold<a class="headerlink" href="#module-pymanopt.manifolds.sphere" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.Sphere">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">Sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#Sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.Sphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._Sphere</span></code></p>
<p>Manifold of shape n1 x n2 x … x nk tensors with unit 2-norm. The
metric is such that the sphere is a Riemannian submanifold of Euclidean
space.</p>
<p>The implementation of the Weingarten map is taken from <a href="#id6"><span class="problematic" id="id3">[1]_</span></a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets">1</span></dt>
<dd><p>Absil, P-A., Robert Mahony, and Jochen Trumpf. “An extrinsic look at
the Riemannian Hessian.” International Conference on Geometric Science
of Information. Springer, Berlin, Heidelberg, 2013.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Manifold of n-dimensional unit 2-norm vectors intersecting the
r-dimensional subspace of R^n spanned by the columns of the matrix U. This
implementation is based on spheresubspacefactory.m from the Manopt MATLAB
package.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.sphere.</span></span><span class="sig-name descname"><span class="pre">SphereSubspaceComplementIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/sphere.html#SphereSubspaceComplementIntersection"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.sphere.SphereSubspaceComplementIntersection" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.sphere._SphereSubspaceIntersectionManifold</span></code></p>
<p>Manifold of n-dimensional unit 2-norm vectors which are orthogonal to
the r-dimensional subspace of R^n spanned by columns of the matrix U. This
implementation is based on spheresubspacefactory.m from the Manopt MATLAB
package.</p>
</dd></dl>

</section>
<section id="module-pymanopt.manifolds.stiefel">
<span id="the-stiefel-manifold"></span><h3>The Stiefel Manifold<a class="headerlink" href="#module-pymanopt.manifolds.stiefel" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.manifolds.stiefel.</span></span><span class="sig-name descname"><span class="pre">Stiefel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold" title="pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.manifolds.manifold.EuclideanEmbeddedSubmanifold</span></code></a></p>
<p>Factory class for the Stiefel manifold. Instantiation requires the
dimensions n, p to be specified. Optional argument k allows the user to
optimize over the product of k Stiefels.</p>
<p>Elements are represented as n x p matrices (if k == 1), and as k x n x p
matrices if k &gt; 1 (Note that this is different to manopt!).</p>
<dl class="py property">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.typicaldist">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">typicaldist</span></span><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.typicaldist" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “scale” of the manifold. This is used by the
trust-regions solver to determine default initial and maximal
trust-region radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.inner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.inner" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inner product (i.e., the Riemannian metric) between two
tangent vectors <cite>G</cite> and <cite>H</cite> in the tangent space at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.proj" title="Permalink to this definition"></a></dt>
<dd><p>Projects a vector <cite>G</cite> in the ambient space on the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.ehess2rhess">
<span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">egrad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ehess</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Converts the Euclidean gradient <cite>G</cite> and Hessian <cite>H</cite> of a function at
a point <cite>X</cite> along a tangent vector <cite>U</cite> to the Riemannian Hessian of <cite>X</cite>
along <cite>U</cite> on the manifold. This uses the Weingarten map</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.retr">
<span class="sig-name descname"><span class="pre">retr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.retr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.retr" title="Permalink to this definition"></a></dt>
<dd><p>Computes a retraction mapping a vector <cite>G</cite> in the tangent space at
<cite>X</cite> to the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.norm" title="Permalink to this definition"></a></dt>
<dd><p>Computes the norm of a tangent vector <cite>G</cite> in the tangent space at
<cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.rand">
<span class="sig-name descname"><span class="pre">rand</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.rand" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random point on the manifold.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.randvec">
<span class="sig-name descname"><span class="pre">randvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.randvec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.randvec" title="Permalink to this definition"></a></dt>
<dd><p>Returns a random vector in the tangent space at <cite>X</cite>. This does not
follow a specific distribution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.transp">
<span class="sig-name descname"><span class="pre">transp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.transp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.transp" title="Permalink to this definition"></a></dt>
<dd><p>Computes a vector transport which transports a vector <cite>G</cite> in the
tangent space at <cite>X1</cite> to the tangent space at <cite>X2</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.exp">
<span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.exp" title="Permalink to this definition"></a></dt>
<dd><p>Computes the Lie-theoretic exponential map of a tangent vector <cite>U</cite>
at <cite>X</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.manifolds.stiefel.Stiefel.zerovec">
<span class="sig-name descname"><span class="pre">zerovec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/manifolds/stiefel.html#Stiefel.zerovec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.manifolds.stiefel.Stiefel.zerovec" title="Permalink to this definition"></a></dt>
<dd><p>Returns the zero vector in the tangent space at X.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="solvers">
<h2>Solvers<a class="headerlink" href="#solvers" title="Permalink to this headline"></a></h2>
<section id="module-pymanopt.solvers.solver">
<span id="solver"></span><h3>Solver<a class="headerlink" href="#module-pymanopt.solvers.solver" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.solver.Solver">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.solver.</span></span><span class="sig-name descname"><span class="pre">Solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxtime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mingradnorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minstepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxcostevals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logverbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/solver.html#Solver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.solver.Solver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class setting out template for solver classes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.solver.Solver.solve">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/solver.html#Solver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.solver.Solver.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the given <a class="reference internal" href="#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> (starting
from a random initial guess if the optional argument x is not
provided).</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.solvers.conjugate_gradient">
<span id="riemannian-conjugate-gradients"></span><h3>Riemannian Conjugate Gradients<a class="headerlink" href="#module-pymanopt.solvers.conjugate_gradient" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.conjugate_gradient.ConjugateGradient">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.conjugate_gradient.</span></span><span class="sig-name descname"><span class="pre">ConjugateGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orth_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/conjugate_gradient.html#ConjugateGradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Module containing conjugate gradient algorithm based on
conjugategradient.m from the manopt MATLAB package.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuselinesearch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/conjugate_gradient.html#ConjugateGradient.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.conjugate_gradient.ConjugateGradient.solve" title="Permalink to this definition"></a></dt>
<dd><p>Perform optimization using nonlinear conjugate gradient method with
linesearch.
This method first computes the gradient of obj w.r.t. arg, and then
optimizes by moving in a direction that is conjugate to all previous
search directions.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>reuselinesearch=False</dt><dd><p>Whether to reuse the previous linesearch object. Allows to
use information from a previous solve run.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.solvers.nelder_mead">
<span id="the-nelder-mead-algorithm"></span><h3>The Nelder-Mead Algorithm<a class="headerlink" href="#module-pymanopt.solvers.nelder_mead" title="Permalink to this headline"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.solvers.nelder_mead.compute_centroid">
<span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.nelder_mead.</span></span><span class="sig-name descname"><span class="pre">compute_centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manifold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#compute_centroid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.compute_centroid" title="Permalink to this definition"></a></dt>
<dd><p>Compute the centroid of <cite>points</cite> on the <cite>manifold</cite> as Karcher mean.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.nelder_mead.NelderMead">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.nelder_mead.</span></span><span class="sig-name descname"><span class="pre">NelderMead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxcostevals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reflection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#NelderMead"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Nelder-Mead minimization alglorithm for derivative-free minimization
based on neldermead.m and centroid.m from the manopt MATLAB package.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.nelder_mead.NelderMead.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/nelder_mead.html#NelderMead.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.nelder_mead.NelderMead.solve" title="Permalink to this definition"></a></dt>
<dd><p>Perform optimization using a Nelder-Mead minimization algorithm.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.solvers.particle_swarm">
<span id="particle-swarms"></span><h3>Particle Swarms<a class="headerlink" href="#module-pymanopt.solvers.particle_swarm" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.particle_swarm.ParticleSwarm">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.particle_swarm.</span></span><span class="sig-name descname"><span class="pre">ParticleSwarm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maxcostevals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">populationsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nostalgia</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">social</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.4</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/particle_swarm.html#ParticleSwarm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Particle swarm optimization method based on pso.m from the manopt
MATLAB package.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.particle_swarm.ParticleSwarm.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/particle_swarm.html#ParticleSwarm.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.particle_swarm.ParticleSwarm.solve" title="Permalink to this definition"></a></dt>
<dd><p>Perform optimization using the particle swarm optimization algorithm.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost (specified using a theano graph
or as a python function).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Initial population of elements on the
manifold. If None then an initial population will be randomly
generated</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.solvers.steepest_descent">
<span id="the-riemannian-steepest-descent"></span><h3>The Riemannian Steepest Descent<a class="headerlink" href="#module-pymanopt.solvers.steepest_descent" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.steepest_descent.SteepestDescent">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.steepest_descent.</span></span><span class="sig-name descname"><span class="pre">SteepestDescent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linesearch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/steepest_descent.html#SteepestDescent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<p>Steepest descent (gradient descent) algorithm based on
steepestdescent.m from the manopt MATLAB package.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.steepest_descent.SteepestDescent.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuselinesearch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/steepest_descent.html#SteepestDescent.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.steepest_descent.SteepestDescent.solve" title="Permalink to this definition"></a></dt>
<dd><p>Perform optimization using gradient descent with linesearch.
This method first computes the gradient (derivative) of obj
w.r.t. arg, and then optimizes by moving in the direction of
steepest descent (which is the opposite direction to the gradient).
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>problem</dt><dd><p>Pymanopt problem setup using the Problem class, this must
have a .manifold attribute specifying the manifold to optimize
over, as well as a cost and enough information to compute
the gradient of that cost.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x=None</dt><dd><p>Optional parameter. Starting point on the manifold. If none
then a starting point will be randomly generated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>reuselinesearch=False</dt><dd><p>Whether to reuse the previous linesearch object. Allows to
use information from a previous solve run.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>x</dt><dd><p>Local minimum of obj, or if algorithm terminated before
convergence x will be the point at which it terminated.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pymanopt.solvers.trust_regions">
<span id="second-order-riemannian-trust-regions"></span><h3>Second-Order Riemannian Trust Regions<a class="headerlink" href="#module-pymanopt.solvers.trust_regions" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.trust_regions.</span></span><span class="sig-name descname"><span class="pre">TrustRegions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">miniter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_prime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_rand</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/trust_regions.html#TrustRegions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymanopt.solvers.solver.Solver" title="pymanopt.solvers.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.solvers.solver.Solver</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE">
<span class="sig-name descname"><span class="pre">NEGATIVE_CURVATURE</span></span><em class="property"> <span class="pre">=</span> <span class="pre">0</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.NEGATIVE_CURVATURE" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR">
<span class="sig-name descname"><span class="pre">EXCEEDED_TR</span></span><em class="property"> <span class="pre">=</span> <span class="pre">1</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.EXCEEDED_TR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR">
<span class="sig-name descname"><span class="pre">REACHED_TARGET_LINEAR</span></span><em class="property"> <span class="pre">=</span> <span class="pre">2</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_LINEAR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR">
<span class="sig-name descname"><span class="pre">REACHED_TARGET_SUPERLINEAR</span></span><em class="property"> <span class="pre">=</span> <span class="pre">3</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.REACHED_TARGET_SUPERLINEAR" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER">
<span class="sig-name descname"><span class="pre">MAX_INNER_ITER</span></span><em class="property"> <span class="pre">=</span> <span class="pre">4</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MAX_INNER_ITER" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED">
<span class="sig-name descname"><span class="pre">MODEL_INCREASED</span></span><em class="property"> <span class="pre">=</span> <span class="pre">5</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.MODEL_INCREASED" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS">
<span class="sig-name descname"><span class="pre">TCG_STOP_REASONS</span></span><em class="property"> <span class="pre">=</span> <span class="pre">{0:</span> <span class="pre">'negative</span> <span class="pre">curvature',</span> <span class="pre">1:</span> <span class="pre">'exceeded</span> <span class="pre">trust</span> <span class="pre">region',</span> <span class="pre">2:</span> <span class="pre">'reached</span> <span class="pre">target</span> <span class="pre">residual-kappa</span> <span class="pre">(linear)',</span> <span class="pre">3:</span> <span class="pre">'reached</span> <span class="pre">target</span> <span class="pre">residual-theta</span> <span class="pre">(superlinear)',</span> <span class="pre">4:</span> <span class="pre">'maximum</span> <span class="pre">inner</span> <span class="pre">iterations',</span> <span class="pre">5:</span> <span class="pre">'model</span> <span class="pre">increased'}</span></em><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.TCG_STOP_REASONS" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.trust_regions.TrustRegions.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">problem</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mininner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxinner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Delta_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Delta0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/trust_regions.html#TrustRegions.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.trust_regions.TrustRegions.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the given <a class="reference internal" href="#pymanopt.core.problem.Problem" title="pymanopt.core.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymanopt.core.problem.Problem</span></code></a> (starting
from a random initial guess if the optional argument x is not
provided).</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="module-pymanopt.solvers.linesearch">
<span id="line-search-methods"></span><h2>Line-Search Methods<a class="headerlink" href="#module-pymanopt.solvers.linesearch" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.linesearch.LineSearchBackTracking">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.linesearch.</span></span><span class="sig-name descname"><span class="pre">LineSearchBackTracking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contraction_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimism</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suff_decr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchBackTracking"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Back-tracking line-search based on linesearch.m in the manopt MATLAB
package.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.linesearch.LineSearchBackTracking.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objective</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">manifold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchBackTracking.search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchBackTracking.search" title="Permalink to this definition"></a></dt>
<dd><p>Function to perform backtracking line-search.
Arguments:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>objective</dt><dd><p>objective function to optimise</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>manifold</dt><dd><p>manifold to optimise over</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>x</dt><dd><p>starting point on the manifold</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>d</dt><dd><p>tangent vector at x (descent direction)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>df0</dt><dd><p>directional derivative at x along d</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>stepsize</dt><dd><p>norm of the vector retracted to reach newx from x</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>newx</dt><dd><p>next iterate suggested by the line-search</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymanopt.solvers.linesearch.LineSearchAdaptive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">pymanopt.solvers.linesearch.</span></span><span class="sig-name descname"><span class="pre">LineSearchAdaptive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">contraction_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suff_decr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_stepsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchAdaptive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Adaptive line-search</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymanopt.solvers.linesearch.LineSearchAdaptive.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objective</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">man</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/solvers/linesearch.html#LineSearchAdaptive.search"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.solvers.linesearch.LineSearchAdaptive.search" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="autodiff-backends">
<h2>Autodiff Backends<a class="headerlink" href="#autodiff-backends" title="Permalink to this headline"></a></h2>
</section>
<section id="module-pymanopt.tools.multi">
<span id="tools"></span><h2>Tools<a class="headerlink" href="#module-pymanopt.tools.multi" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multiprod">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multiprod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiprod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multiprod" title="Permalink to this definition"></a></dt>
<dd><p>Inspired by MATLAB multiprod function by Paolo de Leva. A and B are
assumed to be arrays containing M matrices, that is, A and B have
dimensions A: (M, N, P), B:(M, P, Q). multiprod multiplies each matrix
in A with the corresponding matrix in B, using matrix multiplication.
so multiprod(A, B) has dimensions (M, N, Q).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multitransp">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multitransp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multitransp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multitransp" title="Permalink to this definition"></a></dt>
<dd><p>Inspired by MATLAB multitransp function by Paolo de Leva. A is assumed to
be an array containing M matrices, each of which has dimension N x P.
That is, A is an M x N x P array. Multitransp then returns an array
containing the M matrix transposes of the matrices in A, each of which
will be P x N.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multihconj">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multihconj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multihconj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multihconj" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multisym">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multisym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multisym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multisym" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multiskew">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multiskew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiskew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multiskew" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multieye">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multieye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multieye"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multieye" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multilog">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multilog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_def</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multilog"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multilog" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.multi.multiexp">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.multi.</span></span><span class="sig-name descname"><span class="pre">multiexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/multi.html#multiexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.multi.multiexp" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-pymanopt.tools.testing">
<span id="testing"></span><h2>Testing<a class="headerlink" href="#module-pymanopt.tools.testing" title="Permalink to this headline"></a></h2>
<p>Module containing tools for testing correctness in Pymanopt. Note, these
currently require autograd.</p>
<p>Note: the methods for generating rgrad, egrad2rgrad, ehess and ehess2rhess
will only be correct if the manifold is a submanifold of Euclidean space,
that is if the projection is an orthogonal projection onto the tangent space.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.testing.rgrad">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.testing.</span></span><span class="sig-name descname"><span class="pre">rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.testing.rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Generates the Riemannain gradient of cost. Cost must be defined using
autograd.numpy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.testing.egrad2rgrad">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.testing.</span></span><span class="sig-name descname"><span class="pre">egrad2rgrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#egrad2rgrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.testing.egrad2rgrad" title="Permalink to this definition"></a></dt>
<dd><p>Generates an egrad2rgrad function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.testing.rhess">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.testing.</span></span><span class="sig-name descname"><span class="pre">rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.testing.rhess" title="Permalink to this definition"></a></dt>
<dd><p>Generates the Riemannian hessian of the cost. Specifically, rhess(cost,
proj)(x, u) is the directional derivatative of cost at point X on the
manifold, in direction u.
cost and proj must be defined using autograd.numpy.
See <a class="reference external" href="http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf">http://sites.uclouvain.be/absil/2013-01/Weingarten_07PA_techrep.pdf</a>
for some discussion.
proj and cost must be defined using autograd.
Currently this is correct but not efficient, because of the jacobian-
vector product. Hopefully this can be fixed in future.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymanopt.tools.testing.ehess2rhess">
<span class="sig-prename descclassname"><span class="pre">pymanopt.tools.testing.</span></span><span class="sig-name descname"><span class="pre">ehess2rhess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">proj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymanopt/tools/testing.html#ehess2rhess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymanopt.tools.testing.ehess2rhess" title="Permalink to this definition"></a></dt>
<dd><p>Generates an ehess2rhess function for a manifold which is a sub-manifold
of Euclidean space.
ehess2rhess(proj)(x, egrad, ehess, u) converts the Euclidean hessian ehess
at the point x to a Riemannian hessian. That is the directional
derivatative of the gradient in the direction u.
proj must be defined using autograd.numpy.
This will not be an efficient implementation because of missing support
for efficient jacobian-vector products in autograd.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Pymanopt" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2021, Jamie Townsend, Niklas Koep, Sebastian Weichwald.
      <span class="lastupdated">Last updated on Nov 10, 2021.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>